From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Markus Rudy <mr@edgeless.systems>
Date: Mon, 22 Sep 2025 17:31:12 +0200
Subject: [PATCH] genpolicy: allow image_guest_pull

This adds an additional version of allow_storage that checks Nydus
guest pull instructions. The agent takes the image reference from the
source field, so this is what we need to check. The driver_options field
is actually not used by the agent, so we remove it from the storage
definition to minimize the attack surface and the fields we need to
verify.

Since containerd removes the image tag if the reference has a digest, we
cannot compare the strings byte for byte. Instead, we only compare the
digest parts, which are considered sufficient to identify an image.
---
 src/agent/src/storage/image_pull_handler.rs | 65 ++-------------------
 src/runtime/virtcontainers/kata_agent.go    | 17 +-----
 src/tools/genpolicy/rules.rego              | 47 +++++++++++----
 src/tools/genpolicy/src/yaml.rs             | 11 ++++
 4 files changed, 53 insertions(+), 87 deletions(-)

diff --git a/src/agent/src/storage/image_pull_handler.rs b/src/agent/src/storage/image_pull_handler.rs
index 74686abf43436d9c5c5117d061f1faed79783f74..e927668e85b61c1d242c1052bf50d7a599e33600 100644
--- a/src/agent/src/storage/image_pull_handler.rs
+++ b/src/agent/src/storage/image_pull_handler.rs
@@ -5,12 +5,12 @@
 
 use super::new_device;
 use crate::confidential_data_hub;
-use crate::confidential_data_hub::image::{is_sandbox, unpack_pause_image};
+use crate::confidential_data_hub::image::unpack_pause_image;
 use crate::rpc::CONTAINER_BASE;
 use crate::storage::{StorageContext, StorageHandler};
 use anyhow::{anyhow, Result};
+use kata_types::mount::StorageDevice;
 use kata_types::mount::KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL;
-use kata_types::mount::{ImagePullVolume, StorageDevice};
 use protocols::agent::Storage;
 use safe_path::scoped_join;
 use std::sync::Arc;
@@ -19,20 +19,6 @@ use tracing::instrument;
 #[derive(Debug)]
 pub struct ImagePullHandler {}
 
-impl ImagePullHandler {
-    fn get_image_info(storage: &Storage) -> Result<ImagePullVolume> {
-        for option in storage.driver_options.iter() {
-            if let Some((key, value)) = option.split_once('=') {
-                if key == KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL {
-                    let imagepull_volume: ImagePullVolume = serde_json::from_str(value)?;
-                    return Ok(imagepull_volume);
-                }
-            }
-        }
-        Err(anyhow!("missing Image information for ImagePull volume"))
-    }
-}
-
 #[async_trait::async_trait]
 impl StorageHandler for ImagePullHandler {
     #[instrument]
@@ -46,9 +32,6 @@ impl StorageHandler for ImagePullHandler {
         storage: Storage,
         ctx: &mut StorageContext,
     ) -> Result<Arc<dyn StorageDevice>> {
-        //Currently the image metadata is not used to pulling image in the guest.
-        let image_pull_volume = Self::get_image_info(&storage)?;
-        debug!(ctx.logger, "image_pull_volume = {:?}", image_pull_volume);
         let image_name = storage.source();
         debug!(ctx.logger, "image_name = {:?}", image_name);
 
@@ -57,11 +40,8 @@ impl StorageHandler for ImagePullHandler {
             .clone()
             .ok_or_else(|| anyhow!("failed to get container id"))?;
 
-        info!(
-            ctx.logger,
-            "image metadata: {:?}", image_pull_volume.metadata
-        );
-        if is_sandbox(&image_pull_volume.metadata) {
+        if cid == ctx.sandbox.lock().await.id {
+            // This is the sandbox container, so we just mount the built-in pause image.
             let mount_path = unpack_pause_image(&cid)?;
             return new_device(mount_path);
         }
@@ -89,40 +69,3 @@ impl StorageHandler for ImagePullHandler {
         new_device(bundle_path)
     }
 }
-
-#[cfg(test)]
-mod tests {
-    use std::collections::HashMap;
-
-    use kata_types::mount::{ImagePullVolume, KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL};
-    use protocols::agent::Storage;
-
-    use crate::storage::image_pull_handler::ImagePullHandler;
-
-    #[test]
-    fn test_get_image_info() {
-        let mut res = HashMap::new();
-        res.insert("key1".to_string(), "value1".to_string());
-        res.insert("key2".to_string(), "value2".to_string());
-
-        let image_pull = ImagePullVolume {
-            metadata: res.clone(),
-        };
-
-        let image_pull_str = serde_json::to_string(&image_pull);
-        assert!(image_pull_str.is_ok());
-
-        let storage = Storage {
-            driver: KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL.to_string(),
-            driver_options: vec![format!("image_guest_pull={}", image_pull_str.ok().unwrap())],
-            ..Default::default()
-        };
-
-        match ImagePullHandler::get_image_info(&storage) {
-            Ok(image_info) => {
-                assert_eq!(image_info.metadata, res);
-            }
-            Err(e) => panic!("err = {}", e),
-        }
-    }
-}
diff --git a/src/runtime/virtcontainers/kata_agent.go b/src/runtime/virtcontainers/kata_agent.go
index ed31e089edecb3708dcb5d4d147b217fb430f81c..027315e26bab88caf28eb5ffda80409a21edbdf2 100644
--- a/src/runtime/virtcontainers/kata_agent.go
+++ b/src/runtime/virtcontainers/kata_agent.go
@@ -1719,7 +1719,7 @@ func getContainerTypeforCRI(c *Container) (string, string) {
 	return "", ""
 }
 
-func handleImageGuestPullBlockVolume(c *Container, virtualVolumeInfo *types.KataVirtualVolume, vol *grpc.Storage) (*grpc.Storage, error) {
+func handleImageGuestPullBlockVolume(c *Container, vol *grpc.Storage) (*grpc.Storage, error) {
 	container_annotations := c.GetAnnotations()
 	containerType, criContainerType := getContainerTypeforCRI(c)
 
@@ -1752,20 +1752,9 @@ func handleImageGuestPullBlockVolume(c *Container, virtualVolumeInfo *types.Kata
 			return nil, fmt.Errorf("Failed to get image name from annotations")
 		}
 	}
-	virtualVolumeInfo.Source = image_ref
 
-	//merge virtualVolumeInfo.ImagePull.Metadata and container_annotations
-	for k, v := range container_annotations {
-		virtualVolumeInfo.ImagePull.Metadata[k] = v
-	}
-
-	no, err := json.Marshal(virtualVolumeInfo.ImagePull)
-	if err != nil {
-		return nil, err
-	}
 	vol.Driver = types.KataVirtualVolumeImageGuestPullType
-	vol.DriverOptions = append(vol.DriverOptions, types.KataVirtualVolumeImageGuestPullType+"="+string(no))
-	vol.Source = virtualVolumeInfo.Source
+	vol.Source = image_ref
 	vol.Fstype = typeOverlayFS
 	return vol, nil
 }
@@ -1776,7 +1765,7 @@ func handleVirtualVolumeStorageObject(c *Container, blockDeviceId string, virtVo
 	if virtVolume.VolumeType == types.KataVirtualVolumeImageGuestPullType {
 		var err error
 		vol = &grpc.Storage{}
-		vol, err = handleImageGuestPullBlockVolume(c, virtVolume, vol)
+		vol, err = handleImageGuestPullBlockVolume(c, vol)
 		if err != nil {
 			return nil, err
 		}
diff --git a/src/tools/genpolicy/rules.rego b/src/tools/genpolicy/rules.rego
index 745b8e389d4c3199f917404d99a030504b6c6996..dd2b6ce6fc457d8e7dae256f06e96cb8a4313995 100644
--- a/src/tools/genpolicy/rules.rego
+++ b/src/tools/genpolicy/rules.rego
@@ -1041,10 +1041,9 @@ allow_storages(p_storages, i_storages, bundle_id, sandbox_id) if {
 
     p_count := count(p_storages)
     i_count := count(i_storages)
-    img_pull_count := count([s | s := i_storages[_]; s.driver == "image_guest_pull"])
-    print("allow_storages: p_count =", p_count, "i_count =", i_count, "img_pull_count =", img_pull_count)
+    print("allow_storages: p_count =", p_count, "i_count =", i_count)
 
-    p_count == i_count - img_pull_count
+    p_count == i_count
 
     every i_storage in i_storages {
         allow_storage(p_storages, i_storage, bundle_id, sandbox_id)
@@ -1070,15 +1069,6 @@ allow_storage(p_storages, i_storage, bundle_id, sandbox_id) if {
 
     print("allow_storage: true")
 }
-allow_storage(p_storages, i_storage, bundle_id, sandbox_id) if {
-    i_storage.driver == "image_guest_pull"
-    print("allow_storage with image_guest_pull: start")
-    i_storage.fstype == "overlay"
-    i_storage.fs_group == null
-    count(i_storage.options) == 0
-    # TODO: Check Mount Point, Source, Driver Options, etc.
-    print("allow_storage with image_guest_pull: true")
-}
 
 allow_storage_source(p_storage, i_storage, bundle_id) if {
     print("allow_storage_source 1: start")
@@ -1108,6 +1098,23 @@ allow_storage_source(p_storage, i_storage, bundle_id) if {
 
     print("allow_storage_source 3: true")
 }
+allow_storage_source(p_storage, i_storage, bundle_id) if {
+    print("allow_storage_source 4: start")
+    p_storage.driver == "image_guest_pull"
+    i_storage.driver == "image_guest_pull"
+    p_source := p_storage.source
+    i_source := i_storage.source
+
+    digest_re := "^[^@]+(@.+)?$"
+
+    print("allow_storage_source 4: p_source =", p_source, "i_source =", i_source)
+
+    p_match := regex.find_all_string_submatch_n(digest_re, p_source, 1)
+    i_match := regex.find_all_string_submatch_n(digest_re, i_source, 1)
+    p_match[0][1] == i_match[0][1]
+
+    print("allow_storage_source 4: true")
+}
 
 allow_storage_options(p_storage, i_storage) if {
     print("allow_storage_options 1: start")
@@ -1161,6 +1168,22 @@ allow_mount_point(p_storage, i_storage, bundle_id, sandbox_id) if {
 
     print("allow_mount_point 3: true")
 }
+allow_mount_point(p_storage, i_storage, bundle_id, sandbox_id) if {
+    p_storage.fstype == "overlay"
+
+    mount1 := p_storage.mount_point
+    print("allow_mount_point 2: mount1 =", mount1)
+
+    mount2 := replace(mount1, "$(root_path)", policy_data.common.root_path)
+    print("allow_mount_point 2: mount2 =", mount2)
+
+    mount3 := replace(mount2, "$(bundle-id)", bundle_id)
+    print("allow_mount_point 2: mount3 =", mount3)
+
+    regex.match(mount3, i_storage.mount_point)
+
+    print("allow_mount_point 2: true")
+}
 
 # ExecProcessRequest.process.Capabilities
 allow_exec_caps(i_caps) if {
diff --git a/src/tools/genpolicy/src/yaml.rs b/src/tools/genpolicy/src/yaml.rs
index 7fb078b34043ed6c6cc04c6e4bd8596fa2d46419..c640694c22404b8501f843dfc3dcfb2ee7bd5c6d 100644
--- a/src/tools/genpolicy/src/yaml.rs
+++ b/src/tools/genpolicy/src/yaml.rs
@@ -321,6 +321,17 @@ pub fn get_container_mounts_and_storages(
             mount_and_storage::get_image_mount_and_storage(settings, policy_mounts, volume.0);
         }
     }
+    if settings.cluster_config.guest_pull {
+        storages.push(agent::Storage{
+            driver: "image_guest_pull".to_string(),
+            driver_options: Vec::new(),
+            source: container.image.clone(),
+            fstype: "overlay".to_string(),
+            options: Vec::new(),
+            mount_point: "^$(root_path)$".to_string(),
+            ..Default::default()
+        });
+    }
 }
 
 /// Add the [`KATA_ANNO_CFG_HYPERVISOR_INIT_DATA`] into
