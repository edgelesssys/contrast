From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Charlotte Hartmann Paludo <git@charlotteharludo.com>
Date: Tue, 28 Oct 2025 08:14:40 +0100
Subject: [PATCH] runtime: pass imagepuller config device to vm

Signed-off-by: Charlotte Hartmann Paludo <git@charlotteharludo.com>
---
 src/runtime/pkg/katautils/config.go          |  2 +
 src/runtime/virtcontainers/hypervisor.go     | 65 ++++++++++++++++++--
 src/runtime/virtcontainers/qemu.go           | 10 ++-
 src/runtime/virtcontainers/qemu_arch_base.go |  6 +-
 src/runtime/virtcontainers/qemu_test.go      |  2 +-
 5 files changed, 75 insertions(+), 10 deletions(-)

diff --git a/src/runtime/pkg/katautils/config.go b/src/runtime/pkg/katautils/config.go
index 39d2739ce79d021f9d0d9ab4c605106bdfbdafe6..420bb00f498efdfebfd142a09b3b3751388115dc 100644
--- a/src/runtime/pkg/katautils/config.go
+++ b/src/runtime/pkg/katautils/config.go
@@ -172,6 +172,7 @@ type hypervisor struct {
 	DisableGuestSeLinux            bool                      `toml:"disable_guest_selinux"`
 	LegacySerial                   bool                      `toml:"use_legacy_serial"`
 	ExtraMonitorSocket             govmmQemu.MonitorProtocol `toml:"extra_monitor_socket"`
+	ImagepullerConfigPath          string                    `toml:"contrast_imagepuller_config"`
 }
 
 type runtime struct {
@@ -995,6 +996,7 @@ func newQemuHypervisorConfig(h hypervisor) (vc.HypervisorConfig, error) {
 		SnpIdBlock:               h.SnpIdBlock,
 		SnpIdAuth:                h.SnpIdAuth,
 		SnpGuestPolicy:           h.SnpGuestPolicy,
+		ImagepullerConfigPath:    h.ImagepullerConfigPath,
 	}, nil
 }
 
diff --git a/src/runtime/virtcontainers/hypervisor.go b/src/runtime/virtcontainers/hypervisor.go
index c95c84fdfcfa282498290288bf43e4b681360fd8..05ef3b83a797d16f0607bce732530c31032fefab 100644
--- a/src/runtime/virtcontainers/hypervisor.go
+++ b/src/runtime/virtcontainers/hypervisor.go
@@ -704,6 +704,13 @@ type HypervisorConfig struct {
 	// as a raw block device to guest
 	InitdataImage string
 
+	// ImagepullerConfigPath is the path to the optional imagepuller config.
+	ImagepullerConfigPath string
+
+	// The imagepuller config image on the host side to be mounted
+	// as a raw block device to the guest
+	ImagepullerConfigImage string
+
 	// GPU specific annotations (currently only applicable for Remote Hypervisor)
 	//DefaultGPUs specifies the number of GPUs required for the Kata VM
 	DefaultGPUs uint32
@@ -1210,7 +1217,7 @@ func prepareInitdataMount(logger *logrus.Entry, id string, config *HypervisorCon
 		return err
 	}
 
-	if err := prepareInitdataImage(config.Initdata, initdataImagePath); err != nil {
+	if err := prepareInitdataImage("initdata", []byte(config.Initdata), initdataImagePath); err != nil {
 		logger.WithField("initdata", "prepare initdata image").WithError(err).Error("prepare failed")
 		return err
 	}
@@ -1219,9 +1226,53 @@ func prepareInitdataMount(logger *logrus.Entry, id string, config *HypervisorCon
 	return nil
 }
 
+// prepareImagepullerConfigMount prepares the on-disk imagepuller config initdata image for a VM/sandbox.
+//
+// It reads the InsecureConfig from the config.ImagepullerConfigPath location,
+// creates a working directory at /run/kata-containers/shared/initdata/<id>, builds the image file
+// (data.img) via prepareInitdataImage, and sets config.ImagepullerConfigImage to the
+// resulting absolute path.
+func prepareImagepullerConfigMount(logger *logrus.Entry, id string, config *HypervisorConfig) error {
+	if config.ImagepullerConfigPath == "" {
+		logger.Info("No imagepuller config provided. Skipping prepare imagepuller config device")
+		return nil
+	}
+	if _, err := os.Stat(config.ImagepullerConfigPath); errors.Is(err, os.ErrNotExist) {
+		logger.
+			WithField("imagepuller_config_path", config.ImagepullerConfigPath).
+			Info("Imagepuller config file does not exist. Skipping prepare imagepuller config device")
+		return nil
+	} else if err != nil {
+		return err
+	}
+
+	content, err := os.ReadFile(config.ImagepullerConfigPath)
+	if err != nil {
+		logger.WithField("initdata", "read imagepuller config file").WithError(err).Error("reading config failed")
+		return err
+	}
+
+	logger.Info("Start to prepare imagepuller config")
+	initdataWorkdir := filepath.Join("/run/kata-containers/shared/initdata", id)
+	initdataImagePath := filepath.Join(initdataWorkdir, "imagepuller.img")
+
+	if err := os.MkdirAll(initdataWorkdir, 0o755); err != nil {
+		logger.WithField("initdata", "create imagepuller config image path").WithError(err).Error("mkdir failed")
+		return err
+	}
+
+	if err := prepareInitdataImage("imgpullr", content, initdataImagePath); err != nil {
+		logger.WithField("initdata", "prepare imagepuller config image").WithError(err).Error("prepare failed")
+		return err
+	}
+
+	config.ImagepullerConfigImage = initdataImagePath
+	return nil
+}
+
 // prepareInitdataImage will create an image with a very simple layout
 //
-// There will be multiple sectors. The first 8 bytes are Magic number "initdata".
+// There will be multiple sectors. The first 8 bytes are the provided Magic number.
 // Then a "length" field of 8 bytes follows (unsigned int64).
 // Finally the gzipped initdata toml. The image will be padded to an
 // integer multiple of the sector size for alignment.
@@ -1230,13 +1281,17 @@ func prepareInitdataMount(logger *logrus.Entry, id string, config *HypervisorCon
 // 0	  'i' 'n' 'i' 't' 'd' 'a' 't' 'a'  | gzip length in le  |
 // 16	  gzip(initdata toml) ...
 // (end of the last sector)  '\0' paddings
-func prepareInitdataImage(initdata string, imagePath string) error {
+func prepareInitdataImage(magic string, initdata []byte, imagePath string) error {
+	if len(magic) != 8 {
+		return fmt.Errorf("invalid magic id: must be exactly 8 bytes, but %q is %d bytes", magic, len(magic))
+	}
+
 	SectorSize := 512
 	var buf bytes.Buffer
 	gzipper := gzip.NewWriter(&buf)
 	defer gzipper.Close()
 
-	gzipper.Write([]byte(initdata))
+	gzipper.Write(initdata)
 	err := gzipper.Close()
 	if err != nil {
 		return fmt.Errorf("failed to compress initdata: %v", err)
@@ -1257,7 +1312,7 @@ func prepareInitdataImage(initdata string, imagePath string) error {
 	}
 	defer file.Close()
 
-	_, err = file.Write([]byte("initdata"))
+	_, err = file.Write([]byte(magic))
 	if err != nil {
 		return fmt.Errorf("failed to write magic number to initdata image: %v", err)
 	}
diff --git a/src/runtime/virtcontainers/qemu.go b/src/runtime/virtcontainers/qemu.go
index bba70245d2b7e3ff12a9c67e01a6c195d63cd087..0e55fbd8101b82e45777710c97cf55d4dfa8094e 100644
--- a/src/runtime/virtcontainers/qemu.go
+++ b/src/runtime/virtcontainers/qemu.go
@@ -551,6 +551,10 @@ func (q *qemu) CreateVM(ctx context.Context, id string, network Network, hypervi
 		return err
 	}
 
+	if err := prepareImagepullerConfigMount(q.Logger(), q.id, hypervisorConfig); err != nil {
+		return err
+	}
+
 	machine, err := q.getQemuMachine()
 	if err != nil {
 		return err
@@ -650,7 +654,11 @@ func (q *qemu) CreateVM(ctx context.Context, id string, network Network, hypervi
 	}
 
 	if len(hypervisorConfig.Initdata) > 0 {
-		devices = q.arch.buildInitdataDevice(ctx, devices, hypervisorConfig.InitdataImage)
+		devices = q.arch.buildInitdataDevice(ctx, devices, "initdata", hypervisorConfig.InitdataImage)
+	}
+
+	if len(hypervisorConfig.ImagepullerConfigImage) > 0 {
+		devices = q.arch.buildInitdataDevice(ctx, devices, "imagepuller", hypervisorConfig.ImagepullerConfigImage)
 	}
 
 	// some devices configuration may also change kernel params, make sure this is called afterwards
diff --git a/src/runtime/virtcontainers/qemu_arch_base.go b/src/runtime/virtcontainers/qemu_arch_base.go
index 2b6ab7ce5b4f138c13ba580ffafc8f52a634a732..f8b0d4ef973c2edd96d539e80964e5c3f0d5d4ab 100644
--- a/src/runtime/virtcontainers/qemu_arch_base.go
+++ b/src/runtime/virtcontainers/qemu_arch_base.go
@@ -181,7 +181,7 @@ type qemuArch interface {
 	qomGetSlot(qomPath string, qmpCh *qmpChannel) (types.PciSlot, error)
 
 	// buildInitdataDevice creates an initdata device for the given architecture.
-	buildInitdataDevice(ctx context.Context, devices []govmmQemu.Device, initdataImage string) []govmmQemu.Device
+	buildInitdataDevice(ctx context.Context, devices []govmmQemu.Device, id, initdataImage string) []govmmQemu.Device
 }
 
 type qemuArchBase struct {
@@ -969,11 +969,11 @@ func (q *qemuArchBase) qomGetSlot(qomPath string, qmpCh *qmpChannel) (types.PciS
 }
 
 // build initdata device
-func (q *qemuArchBase) buildInitdataDevice(ctx context.Context, devices []govmmQemu.Device, initdataImage string) []govmmQemu.Device {
+func (q *qemuArchBase) buildInitdataDevice(ctx context.Context, devices []govmmQemu.Device, id, initdataImage string) []govmmQemu.Device {
 	device := govmmQemu.BlockDevice{
 		Driver:    govmmQemu.VirtioBlock,
 		Transport: govmmQemu.TransportPCI,
-		ID:        "initdata",
+		ID:        id,
 		File:      initdataImage,
 		SCSI:      false,
 		WCE:       false,
diff --git a/src/runtime/virtcontainers/qemu_test.go b/src/runtime/virtcontainers/qemu_test.go
index 53b0ff716cf3195de26afbce7b3ab7cf792352b1..5643e6e5426e2e86c7dd7f4d59bfc74219e61f4b 100644
--- a/src/runtime/virtcontainers/qemu_test.go
+++ b/src/runtime/virtcontainers/qemu_test.go
@@ -790,7 +790,7 @@ func TestPrepareInitdataImage(t *testing.T) {
 		t.Run(tt.name, func(t *testing.T) {
 			imageDir := t.TempDir()
 			imagePath := path.Join(imageDir, "initdata.img")
-			err := prepareInitdataImage(tt.content, imagePath)
+			err := prepareInitdataImage("initdata", []byte(tt.content), imagePath)
 			if err != nil {
 				t.Errorf("prepareInitdataImage() error = %v", err)
 			}
