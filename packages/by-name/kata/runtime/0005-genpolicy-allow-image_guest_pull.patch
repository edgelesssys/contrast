From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Markus Rudy <mr@edgeless.systems>
Date: Mon, 22 Sep 2025 17:31:12 +0200
Subject: [PATCH] genpolicy: allow image_guest_pull

This adds an additional version of allow_storage that checks Nydus
guest pull instructions. The agent takes the image reference from the
source field, so this is what we need to check. The driver_options field
is actually not used by the agent, so we remove it from the storage
definition to minimize the attack surface and the fields we need to
verify.

Since containerd removes the image tag if the reference has a digest, we
cannot compare the strings byte for byte. Instead, we only compare the
digest parts, which are considered sufficient to identify an image.
---
 src/agent/src/storage/image_pull_handler.rs | 65 ++-------------------
 src/runtime/virtcontainers/kata_agent.go    | 17 +-----
 src/tools/genpolicy/rules.rego              | 47 +++++++++++----
 src/tools/genpolicy/src/yaml.rs             | 11 ++++
 4 files changed, 53 insertions(+), 87 deletions(-)

diff --git a/src/agent/src/storage/image_pull_handler.rs b/src/agent/src/storage/image_pull_handler.rs
index 74686abf43436d9c5c5117d061f1faed79783f74..e927668e85b61c1d242c1052bf50d7a599e33600 100644
--- a/src/agent/src/storage/image_pull_handler.rs
+++ b/src/agent/src/storage/image_pull_handler.rs
@@ -5,12 +5,12 @@
 
 use super::new_device;
 use crate::confidential_data_hub;
-use crate::confidential_data_hub::image::{is_sandbox, unpack_pause_image};
+use crate::confidential_data_hub::image::unpack_pause_image;
 use crate::rpc::CONTAINER_BASE;
 use crate::storage::{StorageContext, StorageHandler};
 use anyhow::{anyhow, Result};
+use kata_types::mount::StorageDevice;
 use kata_types::mount::KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL;
-use kata_types::mount::{ImagePullVolume, StorageDevice};
 use protocols::agent::Storage;
 use safe_path::scoped_join;
 use std::sync::Arc;
@@ -19,20 +19,6 @@ use tracing::instrument;
 #[derive(Debug)]
 pub struct ImagePullHandler {}
 
-impl ImagePullHandler {
-    fn get_image_info(storage: &Storage) -> Result<ImagePullVolume> {
-        for option in storage.driver_options.iter() {
-            if let Some((key, value)) = option.split_once('=') {
-                if key == KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL {
-                    let imagepull_volume: ImagePullVolume = serde_json::from_str(value)?;
-                    return Ok(imagepull_volume);
-                }
-            }
-        }
-        Err(anyhow!("missing Image information for ImagePull volume"))
-    }
-}
-
 #[async_trait::async_trait]
 impl StorageHandler for ImagePullHandler {
     #[instrument]
@@ -46,9 +32,6 @@ impl StorageHandler for ImagePullHandler {
         storage: Storage,
         ctx: &mut StorageContext,
     ) -> Result<Arc<dyn StorageDevice>> {
-        //Currently the image metadata is not used to pulling image in the guest.
-        let image_pull_volume = Self::get_image_info(&storage)?;
-        debug!(ctx.logger, "image_pull_volume = {:?}", image_pull_volume);
         let image_name = storage.source();
         debug!(ctx.logger, "image_name = {:?}", image_name);
 
@@ -57,11 +40,8 @@ impl StorageHandler for ImagePullHandler {
             .clone()
             .ok_or_else(|| anyhow!("failed to get container id"))?;
 
-        info!(
-            ctx.logger,
-            "image metadata: {:?}", image_pull_volume.metadata
-        );
-        if is_sandbox(&image_pull_volume.metadata) {
+        if cid == ctx.sandbox.lock().await.id {
+            // This is the sandbox container, so we just mount the built-in pause image.
             let mount_path = unpack_pause_image(&cid)?;
             return new_device(mount_path);
         }
@@ -89,40 +69,3 @@ impl StorageHandler for ImagePullHandler {
         new_device(bundle_path)
     }
 }
-
-#[cfg(test)]
-mod tests {
-    use std::collections::HashMap;
-
-    use kata_types::mount::{ImagePullVolume, KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL};
-    use protocols::agent::Storage;
-
-    use crate::storage::image_pull_handler::ImagePullHandler;
-
-    #[test]
-    fn test_get_image_info() {
-        let mut res = HashMap::new();
-        res.insert("key1".to_string(), "value1".to_string());
-        res.insert("key2".to_string(), "value2".to_string());
-
-        let image_pull = ImagePullVolume {
-            metadata: res.clone(),
-        };
-
-        let image_pull_str = serde_json::to_string(&image_pull);
-        assert!(image_pull_str.is_ok());
-
-        let storage = Storage {
-            driver: KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL.to_string(),
-            driver_options: vec![format!("image_guest_pull={}", image_pull_str.ok().unwrap())],
-            ..Default::default()
-        };
-
-        match ImagePullHandler::get_image_info(&storage) {
-            Ok(image_info) => {
-                assert_eq!(image_info.metadata, res);
-            }
-            Err(e) => panic!("err = {}", e),
-        }
-    }
-}
diff --git a/src/runtime/virtcontainers/kata_agent.go b/src/runtime/virtcontainers/kata_agent.go
index fef95c47376b1b2c05304d3f9750e3f84cc93b4a..59ccaf3c86663f12bf2323cc3ddd12573b3e1d98 100644
--- a/src/runtime/virtcontainers/kata_agent.go
+++ b/src/runtime/virtcontainers/kata_agent.go
@@ -1694,7 +1694,7 @@ func getContainerTypeforCRI(c *Container) (string, string) {
 	return "", ""
 }
 
-func handleImageGuestPullBlockVolume(c *Container, virtualVolumeInfo *types.KataVirtualVolume, vol *grpc.Storage) (*grpc.Storage, error) {
+func handleImageGuestPullBlockVolume(c *Container, vol *grpc.Storage) (*grpc.Storage, error) {
 	container_annotations := c.GetAnnotations()
 	containerType, criContainerType := getContainerTypeforCRI(c)
 
@@ -1727,20 +1727,9 @@ func handleImageGuestPullBlockVolume(c *Container, virtualVolumeInfo *types.Kata
 			return nil, fmt.Errorf("Failed to get image name from annotations")
 		}
 	}
-	virtualVolumeInfo.Source = image_ref
 
-	//merge virtualVolumeInfo.ImagePull.Metadata and container_annotations
-	for k, v := range container_annotations {
-		virtualVolumeInfo.ImagePull.Metadata[k] = v
-	}
-
-	no, err := json.Marshal(virtualVolumeInfo.ImagePull)
-	if err != nil {
-		return nil, err
-	}
 	vol.Driver = types.KataVirtualVolumeImageGuestPullType
-	vol.DriverOptions = append(vol.DriverOptions, types.KataVirtualVolumeImageGuestPullType+"="+string(no))
-	vol.Source = virtualVolumeInfo.Source
+	vol.Source = image_ref
 	vol.Fstype = typeOverlayFS
 	return vol, nil
 }
@@ -1751,7 +1740,7 @@ func handleVirtualVolumeStorageObject(c *Container, blockDeviceId string, virtVo
 	if virtVolume.VolumeType == types.KataVirtualVolumeImageGuestPullType {
 		var err error
 		vol = &grpc.Storage{}
-		vol, err = handleImageGuestPullBlockVolume(c, virtVolume, vol)
+		vol, err = handleImageGuestPullBlockVolume(c, vol)
 		if err != nil {
 			return nil, err
 		}
diff --git a/src/tools/genpolicy/rules.rego b/src/tools/genpolicy/rules.rego
index c45754a94c32b917cb61deb95dda9bafc0ec1286..ab17b679cb32ce602f7129fd6a6e1e0e4b322c63 100644
--- a/src/tools/genpolicy/rules.rego
+++ b/src/tools/genpolicy/rules.rego
@@ -1018,10 +1018,9 @@ mount_source_allows(p_mount, i_mount, bundle_id, sandbox_id) if {
 allow_storages(p_storages, i_storages, bundle_id, sandbox_id) if {
     p_count := count(p_storages)
     i_count := count(i_storages)
-    img_pull_count := count([s | s := i_storages[_]; s.driver == "image_guest_pull"])
-    print("allow_storages: p_count =", p_count, "i_count =", i_count, "img_pull_count =", img_pull_count)
+    print("allow_storages: p_count =", p_count, "i_count =", i_count)
 
-    p_count == i_count - img_pull_count
+    p_count == i_count
 
     every i_storage in i_storages {
         allow_storage(p_storages, i_storage, bundle_id, sandbox_id)
@@ -1047,15 +1046,6 @@ allow_storage(p_storages, i_storage, bundle_id, sandbox_id) if {
 
     print("allow_storage: true")
 }
-allow_storage(p_storages, i_storage, bundle_id, sandbox_id) if {
-    i_storage.driver == "image_guest_pull"
-    print("allow_storage with image_guest_pull: start")
-    i_storage.fstype == "overlay"
-    i_storage.fs_group == null
-    count(i_storage.options) == 0
-    # TODO: Check Mount Point, Source, Driver Options, etc.
-    print("allow_storage with image_guest_pull: true")
-}
 
 allow_storage_source(p_storage, i_storage, bundle_id) if {
     print("allow_storage_source 1: start")
@@ -1085,6 +1075,23 @@ allow_storage_source(p_storage, i_storage, bundle_id) if {
 
     print("allow_storage_source 3: true")
 }
+allow_storage_source(p_storage, i_storage, bundle_id) if {
+    print("allow_storage_source 4: start")
+    p_storage.driver == "image_guest_pull"
+    i_storage.driver == "image_guest_pull"
+    p_source := p_storage.source
+    i_source := i_storage.source
+
+    digest_re := "^[^@]+(@.+)?$"
+
+    print("allow_storage_source 4: p_source =", p_source, "i_source =", i_source)
+
+    p_match := regex.find_all_string_submatch_n(digest_re, p_source, 1)
+    i_match := regex.find_all_string_submatch_n(digest_re, i_source, 1)
+    p_match[0][1] == i_match[0][1]
+
+    print("allow_storage_source 4: true")
+}
 
 allow_storage_options(p_storage, i_storage) if {
     print("allow_storage_options 1: start")
@@ -1138,6 +1145,22 @@ allow_mount_point(p_storage, i_storage, bundle_id, sandbox_id) if {
 
     print("allow_mount_point 3: true")
 }
+allow_mount_point(p_storage, i_storage, bundle_id, sandbox_id) if {
+    p_storage.fstype == "overlay"
+
+    mount1 := p_storage.mount_point
+    print("allow_mount_point 2: mount1 =", mount1)
+
+    mount2 := replace(mount1, "$(root_path)", policy_data.common.root_path)
+    print("allow_mount_point 2: mount2 =", mount2)
+
+    mount3 := replace(mount2, "$(bundle-id)", bundle_id)
+    print("allow_mount_point 2: mount3 =", mount3)
+
+    regex.match(mount3, i_storage.mount_point)
+
+    print("allow_mount_point 2: true")
+}
 
 # ExecProcessRequest.process.Capabilities
 allow_exec_caps(i_caps) if {
diff --git a/src/tools/genpolicy/src/yaml.rs b/src/tools/genpolicy/src/yaml.rs
index 131d2ce0b467170286424e53baa3dc281c29e439..63cbb1ea595bc228874a43dfd2f79dc5266a2bee 100644
--- a/src/tools/genpolicy/src/yaml.rs
+++ b/src/tools/genpolicy/src/yaml.rs
@@ -316,6 +316,17 @@ pub fn get_container_mounts_and_storages(
             mount_and_storage::get_image_mount_and_storage(settings, policy_mounts, volume.0);
         }
     }
+    if settings.cluster_config.guest_pull {
+        storages.push(agent::Storage{
+            driver: "image_guest_pull".to_string(),
+            driver_options: Vec::new(),
+            source: container.image.clone(),
+            fstype: "overlay".to_string(),
+            options: Vec::new(),
+            mount_point: "^$(root_path)$".to_string(),
+            ..Default::default()
+        });
+    }
 }
 
 /// Add the "io.katacontainers.config.agent.policy" annotation into
