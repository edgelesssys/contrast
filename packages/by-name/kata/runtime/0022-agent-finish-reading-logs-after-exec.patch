From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Markus Rudy <mr@edgeless.systems>
Date: Mon, 2 Feb 2026 12:18:19 +0100
Subject: [PATCH] agent: finish reading logs after exec

---
 src/agent/src/rpc.rs | 30 +++++++++++++-----------------
 1 file changed, 13 insertions(+), 17 deletions(-)

diff --git a/src/agent/src/rpc.rs b/src/agent/src/rpc.rs
index 0ef1e4a2fbac4d67bcb13d324d1df98bfa0067e9..128f4023283b5a105168bb399875d0e2657a7b99 100644
--- a/src/agent/src/rpc.rs
+++ b/src/agent/src/rpc.rs
@@ -700,25 +700,21 @@ impl AgentService {
 
         let reader = reader.ok_or_else(|| anyhow!("cannot get stream reader"))?;
 
-        tokio::select! {
-            // Poll the futures in the order they appear from top to bottom
-            // it is very important to avoid data loss. If there is still
-            // data in the buffer and read_stream branch will return
-            // Poll::Ready so that the term_exit_notifier will never polled
-            // before all data were read.
-            biased;
-            v = read_stream(&reader, req.len as usize)  => {
-                let vector = v?;
-
-                let mut resp = ReadStreamResponse::new();
-                resp.set_data(vector);
-
-                Ok(resp)
-            }
+        let mut reader_promise = Box::pin(read_stream(&reader, req.len as usize));
+        let vector = tokio::select! {
+            v = &mut reader_promise => v,
             _ = term_exit_notifier.notified() => {
-                Err(anyhow!("eof"))
+                // The process exited, but the read may still be in flight.
+                // Wait a second for all data to propagate.
+                let one_second_timeout = std::time::Duration::new(1, 0);
+                tokio::time::timeout(one_second_timeout, reader_promise).await?
             }
-        }
+        }?;
+
+        let mut resp = ReadStreamResponse::new();
+        resp.set_data(vector);
+
+        Ok(resp)
     }
 }
 
