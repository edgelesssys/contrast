From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tom Dohrmann <erbse.13@gmx.de>
Date: Mon, 8 Jul 2024 07:51:20 +0000
Subject: [PATCH] runtime: agent: verify the agent policy hash

For TEE Guests that support the inclusion of immutable Host owned
data in their configuration (SNP HostData and TDX MRCONFIGID):

- runtime: attach the Agent Policy hash to these Guest VMs.
- agent: compute the hash of the Agent Policy and verify that it
  matches the TEE configuration data.

The hash value attached to the TEE will be included in the TEE
attestation reports. This allows an attestation service to verify that
the hash has the expected value, and therefore the Policy enforced by
the Agent has the expected contents.

Signed-off-by: Dan Mihai <dmihai@microsoft.com>
Signed-off-by: Tom Dohrmann <erbse.13@gmx.de>
---
 src/agent/Cargo.lock                          | 105 +++++++++-
 src/agent/Cargo.toml                          |   7 +-
 src/agent/src/main.rs                         |   4 +
 src/agent/src/policy.rs                       |  46 ++++-
 src/agent/src/sev.rs                          |  19 ++
 src/agent/src/tdx.rs                          | 194 ++++++++++++++++++
 src/runtime/pkg/govmm/qemu/qemu.go            |  17 +-
 src/runtime/virtcontainers/hypervisor.go      |  12 +-
 src/runtime/virtcontainers/qemu.go            |   2 +-
 src/runtime/virtcontainers/qemu_amd64.go      |  39 +++-
 src/runtime/virtcontainers/qemu_amd64_test.go | 116 ++++++++++-
 src/runtime/virtcontainers/qemu_arch_base.go  |   4 +-
 src/runtime/virtcontainers/qemu_arm64.go      |   2 +-
 src/runtime/virtcontainers/qemu_arm64_test.go |  47 ++++-
 src/runtime/virtcontainers/qemu_ppc64le.go    |   2 +-
 .../virtcontainers/qemu_ppc64le_test.go       |  53 ++++-
 src/runtime/virtcontainers/qemu_s390x.go      |   2 +-
 src/runtime/virtcontainers/qemu_s390x_test.go |  51 ++++-
 src/runtime/virtcontainers/sandbox.go         |   1 +
 19 files changed, 680 insertions(+), 43 deletions(-)
 create mode 100644 src/agent/src/sev.rs
 create mode 100644 src/agent/src/tdx.rs

diff --git a/src/agent/Cargo.lock b/src/agent/Cargo.lock
index f94f936f6b0695164daaf09bce98c37894f3e1cb..06cd71212acbbe2093c195c0c40a8817e2d88deb 100644
--- a/src/agent/Cargo.lock
+++ b/src/agent/Cargo.lock
@@ -605,6 +605,12 @@ version = "0.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"
 
+[[package]]
+name = "bitfield"
+version = "0.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46afbd2983a5d5a7bd740ccb198caf5b82f45c40c09c0eed36052d91cb92e719"
+
 [[package]]
 name = "bitflags"
 version = "1.3.2"
@@ -1100,11 +1106,17 @@ dependencies = [
  "wasm-bindgen",
 ]
 
+[[package]]
+name = "codicon"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "12170080f3533d6f09a19f81596f836854d0fa4867dc32c8172b8474b4e9de61"
+
 [[package]]
 name = "colorchoice"
-version = "1.0.2"
+version = "1.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d3fd119d74b830634cea2a0f58bbd0d54540518a14397557951e79340abc28c0"
+checksum = "5b63caa9aa9397e2d9480a9b13673856c78d8ac123288526c37d7839f2a86990"
 
 [[package]]
 name = "combine"
@@ -1612,6 +1624,15 @@ dependencies = [
  "subtle",
 ]
 
+[[package]]
+name = "dirs"
+version = "5.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225"
+dependencies = [
+ "dirs-sys",
+]
+
 [[package]]
 name = "dirs-next"
 version = "2.0.0"
@@ -1622,6 +1643,18 @@ dependencies = [
  "dirs-sys-next",
 ]
 
+[[package]]
+name = "dirs-sys"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
+dependencies = [
+ "libc",
+ "option-ext",
+ "redox_users",
+ "windows-sys 0.48.0",
+]
+
 [[package]]
 name = "dirs-sys-next"
 version = "0.1.2"
@@ -2748,6 +2781,12 @@ dependencies = [
  "windows-sys 0.48.0",
 ]
 
+[[package]]
+name = "iocuddle"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d8972d5be69940353d5347a1344cb375d9b457d6809b428b05bb1ca2fb9ce007"
+
 [[package]]
 name = "iovec"
 version = "0.1.4"
@@ -3048,6 +3087,8 @@ dependencies = [
  "serde",
  "serde_json",
  "serial_test",
+ "sev",
+ "sha2",
  "slog",
  "slog-scope",
  "slog-stdlog",
@@ -3065,6 +3106,7 @@ dependencies = [
  "tracing-subscriber",
  "ttrpc",
  "url",
+ "vmm-sys-util",
  "vsock-exporter",
  "which",
 ]
@@ -4070,6 +4112,12 @@ dependencies = [
  "tokio-stream",
 ]
 
+[[package]]
+name = "option-ext"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"
+
 [[package]]
 name = "ordered-stream"
 version = "0.2.0"
@@ -5526,6 +5574,15 @@ dependencies = [
  "syn 1.0.109",
 ]
 
+[[package]]
+name = "serde-big-array"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11fc7cc2c76d73e0f27ee52abbd64eec84d46f370c88371120433196934e4b7f"
+dependencies = [
+ "serde",
+]
+
 [[package]]
 name = "serde-enum-str"
 version = "0.4.0"
@@ -5545,6 +5602,15 @@ version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "794e44574226fc701e3be5c651feb7939038fc67fb73f6f4dd5c4ba90fd3be70"
 
+[[package]]
+name = "serde_bytes"
+version = "0.11.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f3c5113243e4a3a1c96587342d067f3e6b0f50790b6cf40d2868eb647a3eef0e"
+dependencies = [
+ "serde",
+]
+
 [[package]]
 name = "serde_derive"
 version = "1.0.204"
@@ -5648,6 +5714,28 @@ dependencies = [
  "syn 1.0.109",
 ]
 
+[[package]]
+name = "sev"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77e9de97c6e3c65e4e67997d48ad506d258da10edc10894277093da679441f23"
+dependencies = [
+ "bincode",
+ "bitfield",
+ "bitflags 1.3.2",
+ "codicon",
+ "dirs",
+ "hex",
+ "iocuddle",
+ "lazy_static",
+ "libc",
+ "serde",
+ "serde-big-array",
+ "serde_bytes",
+ "static_assertions",
+ "uuid",
+]
+
 [[package]]
 name = "sha1"
 version = "0.10.6"
@@ -6682,6 +6770,9 @@ name = "uuid"
 version = "1.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "81dfa00651efa65069b0b6b651f4aaa31ba9e3c3ce0137aaad053604ee7e0314"
+dependencies = [
+ "serde",
+]
 
 [[package]]
 name = "valuable"
@@ -6701,6 +6792,16 @@ version = "0.9.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"
 
+[[package]]
+name = "vmm-sys-util"
+version = "0.11.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48b7b084231214f7427041e4220d77dfe726897a6d41fddee450696e66ff2a29"
+dependencies = [
+ "bitflags 1.3.2",
+ "libc",
+]
+
 [[package]]
 name = "vsock"
 version = "0.2.6"
diff --git a/src/agent/Cargo.toml b/src/agent/Cargo.toml
index 6b0ab344c18b06fc09d7e09f68b51e8498a71587..8efa57bd87686bed26a143a1febda1979c52469e 100644
--- a/src/agent/Cargo.toml
+++ b/src/agent/Cargo.toml
@@ -89,6 +89,11 @@ regorus = { version = "0.2.6", default-features = false, features = [
 cdi = { git = "https://github.com/cncf-tags/container-device-interface-rs", rev = "fba5677a8e7cc962fc6e495fcec98d7d765e332a" }
 json-patch = "2.0.0"
 
+# Policy validation
+sha2 = { version = "0.10.6", optional = true }
+sev = { version = "2.0.2", default-features = false, features = ["snp"], optional = true }
+vmm-sys-util = { version = "0.11.0", optional = true }
+
 [dev-dependencies]
 tempfile = "3.1.0"
 test-utils = { path = "../libs/test-utils" }
@@ -107,7 +112,7 @@ lto = true
 default-pull = ["guest-pull"]
 seccomp = ["rustjail/seccomp"]
 standard-oci-runtime = ["rustjail/standard-oci-runtime"]
-agent-policy = ["regorus"]
+agent-policy = ["regorus", "sev", "sha2", "vmm-sys-util"]
 guest-pull = ["image-rs/kata-cc-rustls-tls"]
 
 [[bin]]
diff --git a/src/agent/src/main.rs b/src/agent/src/main.rs
index c4df5f4aeccfd812669bac7c8069f11b6d943924..e3cd549673847328169e97968a37881d3334b67e 100644
--- a/src/agent/src/main.rs
+++ b/src/agent/src/main.rs
@@ -85,6 +85,10 @@ mod tracer;
 
 #[cfg(feature = "agent-policy")]
 mod policy;
+#[cfg(feature = "agent-policy")]
+mod sev;
+#[cfg(feature = "agent-policy")]
+mod tdx;
 
 cfg_if! {
     if #[cfg(target_arch = "s390x")] {
diff --git a/src/agent/src/policy.rs b/src/agent/src/policy.rs
index 08587a6d03bb53ed82b62c48b658b9dbd8b07c6c..875a48127f5ceabcb6afb9cedaae74e5e0099d24 100644
--- a/src/agent/src/policy.rs
+++ b/src/agent/src/policy.rs
@@ -3,11 +3,14 @@
 // SPDX-License-Identifier: Apache-2.0
 //
 
-use anyhow::{bail, Result};
+use anyhow::{bail, ensure, Result};
 use protobuf::MessageDyn;
+use sha2::{Digest, Sha256};
 use tokio::io::AsyncWriteExt;
 
 use crate::rpc::ttrpc_error;
+use crate::sev::get_snp_host_data;
+use crate::tdx::get_tdx_mrconfigid;
 use crate::{AGENT_CONFIG, AGENT_POLICY};
 
 static POLICY_LOG_FILE: &str = "/tmp/policy.txt";
@@ -217,6 +220,7 @@ impl AgentPolicy {
 
     /// Replace the Policy in regorus.
     pub async fn set_policy(&mut self, policy: &str) -> Result<()> {
+        verify_policy_digest(policy)?;
         self.engine = Self::new_engine();
         self.engine
             .add_policy("agent_policy".to_string(), policy.to_string())?;
@@ -264,3 +268,43 @@ impl AgentPolicy {
         Ok(())
     }
 }
+
+fn verify_policy_digest(policy: &str) -> Result<()> {
+    if let Ok(expected_digest) = get_tdx_mrconfigid() {
+        info!(sl!(), "policy: TDX MrConfigId ({:?})", expected_digest);
+
+        // The MrConfigId used with TDX is longer than the host-data field used
+        // with SNP, but we don't want to use different hashes for different
+        // platforms. Instead we truncate the MrConfigId to 256-bit and always
+        // use sha-256.
+        let (expected_digest, trailing_data) =
+            expected_digest.split_at(<Sha256 as Digest>::output_size());
+
+        ensure!(
+            trailing_data.iter().all(|&d| d == 0),
+            "hash isn't padded with zeros: MrConfigId={expected_digest:?}"
+        );
+
+        info!(sl!(), "policy: TDX expected digest ({:?})", expected_digest);
+        verify_sha_256(policy, expected_digest)
+    } else if let Ok(expected_digest) = get_snp_host_data() {
+        info!(sl!(), "policy: SNP expected digest ({:?})", expected_digest);
+        verify_sha_256(policy, expected_digest.as_slice())
+    } else {
+        bail!("couldn't find host data to verify the integrity of the policy");
+    }
+}
+
+pub fn verify_sha_256(policy: &str, expected_digest: &[u8]) -> Result<()> {
+    let mut hasher = Sha256::new();
+    hasher.update(policy.as_bytes());
+    let digest = hasher.finalize();
+    info!(sl!(), "policy: calculated digest ({:?})", digest);
+    ensure!(
+        expected_digest == digest.as_slice(),
+        "policy: rejecting unexpected digest ({:?}), expected ({:?})",
+        digest,
+        expected_digest
+    );
+    Ok(())
+}
diff --git a/src/agent/src/sev.rs b/src/agent/src/sev.rs
new file mode 100644
index 0000000000000000000000000000000000000000..3257eabafcc971df7219d71186383616ee19a672
--- /dev/null
+++ b/src/agent/src/sev.rs
@@ -0,0 +1,19 @@
+// Copyright (c) 2023 Microsoft Corporation
+//
+// SPDX-License-Identifier: Apache-2.0
+//
+
+use anyhow::Result;
+
+pub fn get_snp_host_data() -> Result<Vec<u8>> {
+    match sev::firmware::guest::Firmware::open() {
+        Ok(mut firmware) => {
+            let report_data: [u8; 64] = [0; 64];
+            match firmware.get_report(None, Some(report_data), Some(0)) {
+                Ok(report) => Ok(report.host_data.to_vec()),
+                Err(e) => Err(e.into()),
+            }
+        }
+        Err(e) => Err(e.into()),
+    }
+}
diff --git a/src/agent/src/tdx.rs b/src/agent/src/tdx.rs
new file mode 100644
index 0000000000000000000000000000000000000000..1531e72a8b8db6e357d02ecdd431a9b88af3b30d
--- /dev/null
+++ b/src/agent/src/tdx.rs
@@ -0,0 +1,194 @@
+// Copyright (c) 2023 Microsoft Corporation
+//
+// SPDX-License-Identifier: Apache-2.0
+//
+
+use anyhow::{bail, Result};
+use nix::fcntl::{self, OFlag};
+use nix::sys::stat::Mode;
+use std::os::fd::{AsRawFd, FromRawFd};
+use vmm_sys_util::ioctl::ioctl_with_val;
+use vmm_sys_util::{ioctl_ioc_nr, ioctl_iowr_nr};
+
+#[repr(C)]
+#[derive(Default)]
+/// Type header of TDREPORT_STRUCT.
+struct TdTransportType {
+    /// Type of the TDREPORT (0 - SGX, 81 - TDX, rest are reserved).
+    type_: u8,
+
+    /// Subtype of the TDREPORT (Default value is 0).
+    sub_type: u8,
+
+    /// TDREPORT version (Default value is 0).
+    version: u8,
+
+    /// Added for future extension.
+    reserved: u8,
+}
+
+#[repr(C)]
+/// TDX guest report data, MAC and TEE hashes.
+struct ReportMac {
+    /// TDREPORT type header.
+    type_: TdTransportType,
+
+    /// Reserved for future extension.
+    reserved1: [u8; 12],
+
+    /// CPU security version.
+    cpu_svn: [u8; 16],
+
+    /// SHA384 hash of TEE TCB INFO.
+    tee_tcb_info_hash: [u8; 48],
+
+    /// SHA384 hash of TDINFO_STRUCT.
+    tee_td_info_hash: [u8; 48],
+
+    /// User defined unique data passed in TDG.MR.REPORT request.
+    reportdata: [u8; 64],
+
+    /// Reserved for future extension.
+    reserved2: [u8; 32],
+
+    /// CPU MAC ID.
+    mac: [u8; 32],
+}
+
+impl Default for ReportMac {
+    fn default() -> Self {
+        Self {
+            type_: Default::default(),
+            reserved1: [0; 12],
+            cpu_svn: [0; 16],
+            tee_tcb_info_hash: [0; 48],
+            tee_td_info_hash: [0; 48],
+            reportdata: [0; 64],
+            reserved2: [0; 32],
+            mac: [0; 32],
+        }
+    }
+}
+
+#[repr(C)]
+#[derive(Default)]
+/// TDX guest measurements and configuration.
+struct TdInfo {
+    /// TDX Guest attributes (like debug, spet_disable, etc).
+    attr: [u8; 8],
+
+    /// Extended features allowed mask.
+    xfam: u64,
+
+    /// Build time measurement register.
+    mrtd: [u64; 6],
+
+    /// Software-defined ID for non-owner-defined configuration of the guest - e.g., run-time or OS configuration.
+    mrconfigid: [u64; 6],
+
+    /// Software-defined ID for the guest owner.
+    mrowner: [u64; 6],
+
+    /// Software-defined ID for owner-defined configuration of the guest - e.g., specific to the workload.
+    mrownerconfig: [u64; 6],
+
+    /// Run time measurement registers.
+    rtmr: [u64; 24],
+
+    /// For future extension.
+    reserved: [u64; 14],
+}
+
+#[repr(C)]
+/// Output of TDCALL[TDG.MR.REPORT].
+struct TdReport {
+    /// Mac protected header of size 256 bytes.
+    report_mac: ReportMac,
+
+    /// Additional attestable elements in the TCB are not reflected in the report_mac.
+    tee_tcb_info: [u8; 239],
+
+    /// Added for future extension.
+    reserved: [u8; 17],
+
+    /// Measurements and configuration data of size 512 bytes.
+    tdinfo: TdInfo,
+}
+
+impl Default for TdReport {
+    fn default() -> Self {
+        Self {
+            report_mac: Default::default(),
+            tee_tcb_info: [0; 239],
+            reserved: [0; 17],
+            tdinfo: Default::default(),
+        }
+    }
+}
+
+#[repr(C)]
+/// Request struct for TDX_CMD_GET_REPORT0 IOCTL.
+struct TdxReportReq {
+    /// User buffer with REPORTDATA to be included into TDREPORT.
+    /// Typically it can be some nonce provided by attestation, service,
+    /// so the generated TDREPORT can be uniquely verified.
+    reportdata: [u8; 64],
+
+    /// User buffer to store TDREPORT output from TDCALL[TDG.MR.REPORT].
+    tdreport: TdReport,
+}
+
+impl Default for TdxReportReq {
+    fn default() -> Self {
+        Self {
+            reportdata: [0; 64],
+            tdreport: Default::default(),
+        }
+    }
+}
+
+// Get TDREPORT0 (a.k.a. TDREPORT subtype 0) using TDCALL[TDG.MR.REPORT].
+ioctl_iowr_nr!(
+    TDX_CMD_GET_REPORT0,
+    'T' as ::std::os::raw::c_uint,
+    1,
+    TdxReportReq
+);
+
+pub fn get_tdx_mrconfigid() -> Result<Vec<u8>> {
+    let fd = {
+        let raw_fd = fcntl::open(
+            "/dev/tdx_guest",
+            OFlag::O_CLOEXEC | OFlag::O_RDWR | OFlag::O_SYNC,
+            Mode::empty(),
+        )?;
+        unsafe { std::fs::File::from_raw_fd(raw_fd) }
+    };
+
+    let mut req = TdxReportReq {
+        reportdata: [0; 64],
+        tdreport: Default::default(),
+    };
+    let ret = unsafe {
+        ioctl_with_val(
+            &fd.as_raw_fd(),
+            TDX_CMD_GET_REPORT0(),
+            &mut req as *mut TdxReportReq as std::os::raw::c_ulong,
+        )
+    };
+    if ret < 0 {
+        bail!(
+            "TDX_CMD_GET_REPORT0 failed: {:?}",
+            std::io::Error::last_os_error(),
+        );
+    }
+
+    let mrconfigid: Vec<u8> = req
+        .tdreport
+        .tdinfo
+        .mrconfigid
+        .iter()
+        .flat_map(|val| val.to_le_bytes())
+        .collect();
+    Ok(mrconfigid)
+}
diff --git a/src/runtime/pkg/govmm/qemu/qemu.go b/src/runtime/pkg/govmm/qemu/qemu.go
index b3b3fb4bdbe99e6fc1a89db49be984b92a19551c..5070ecd1e78ca04383637e662b3c8e4f8ec0ae5e 100644
--- a/src/runtime/pkg/govmm/qemu/qemu.go
+++ b/src/runtime/pkg/govmm/qemu/qemu.go
@@ -320,6 +320,11 @@ type Object struct {
 
 	// QgsPort defines Intel Quote Generation Service port exposed from the host
 	QgsPort uint32
+
+	// TEEConfigData represents opaque binary data attached to a TEE and typically used
+	// for Guest attestation. This is only relevant for sev-snp-guest and tdx-guest
+	// objects and is encoded in the format expected by QEMU for each TEE type.
+	TEEConfigData string
 }
 
 // Valid returns true if the Object structure is valid and complete.
@@ -395,6 +400,9 @@ func (object Object) QemuParams(config *Config) []string {
 		if object.SnpCertsPath != "" {
 			objectParams = append(objectParams, fmt.Sprintf("certs-path=%s", object.SnpCertsPath))
 		}
+		if len(object.TEEConfigData) > 0 {
+			objectParams = append(objectParams, fmt.Sprintf("host-data=%s", object.TEEConfigData))
+		}
 		config.Bios = object.File
 	case SecExecGuest:
 		objectParams = append(objectParams, string(object.Type))
@@ -435,6 +443,7 @@ type SocketAddress struct {
 type TdxQomObject struct {
 	QomType               string        `json:"qom-type"`
 	Id                    string        `json:"id"`
+	SeptVEDisable         *bool         `json:"sept-ve-disable,omitempty"`
 	MrConfigId            string        `json:"mrconfigid,omitempty"`
 	MrOwner               string        `json:"mrowner,omitempty"`
 	MrOwnerConfig         string        `json:"mrownerconfig,omitempty"`
@@ -469,6 +478,7 @@ func prepareTDXObject(object Object) string {
 	tdxObject := TdxQomObject{
 		string(object.Type), // qom-type
 		object.ID,           // id
+		nil,                 // sept-ve-disable
 		"",                  // mrconfigid
 		"",                  // mrowner
 		"",                  // mrownerconfig
@@ -476,7 +486,12 @@ func prepareTDXObject(object Object) string {
 		nil}
 
 	if object.Debug {
-		*tdxObject.Debug = true
+		t := true
+		tdxObject.Debug = &t
+	}
+
+	if len(object.TEEConfigData) > 0 {
+		tdxObject.MrConfigId = object.TEEConfigData
 	}
 
 	return tdxObject.String()
diff --git a/src/runtime/virtcontainers/hypervisor.go b/src/runtime/virtcontainers/hypervisor.go
index cad5e85d7440550422154729e443448a9223250d..646720f3261e361ee0893dd511d6c11b2a7706c6 100644
--- a/src/runtime/virtcontainers/hypervisor.go
+++ b/src/runtime/virtcontainers/hypervisor.go
@@ -545,7 +545,7 @@ type HypervisorConfig struct {
 	// NumVCPUs specifies default number of vCPUs for the VM.
 	NumVCPUsF float32
 
-	//DefaultMaxVCPUs specifies the maximum number of vCPUs for the VM.
+	// DefaultMaxVCPUs specifies the maximum number of vCPUs for the VM.
 	DefaultMaxVCPUs uint32
 
 	// DefaultMem specifies default memory size in MiB for the VM.
@@ -675,10 +675,14 @@ type HypervisorConfig struct {
 	Initdata string
 
 	// GPU specific annotations (currently only applicable for Remote Hypervisor)
-	//DefaultGPUs specifies the number of GPUs required for the Kata VM
+	// DefaultGPUs specifies the number of GPUs required for the Kata VM
 	DefaultGPUs uint32
 	// DefaultGPUModel specifies GPU model like tesla, h100, readeon etc.
 	DefaultGPUModel string
+
+	// Policy text, for sandboxes created using a valid io.katacontainers.config.agent.policy
+	// annotation
+	AgentPolicy string
 }
 
 // vcpu mapping from vcpu number to thread number
@@ -1033,8 +1037,8 @@ type guestProtection uint8
 const (
 	noneProtection guestProtection = iota
 
-	//Intel Trust Domain Extensions
-	//https://software.intel.com/content/www/us/en/develop/articles/intel-trust-domain-extensions.html
+	// Intel Trust Domain Extensions
+	// https://software.intel.com/content/www/us/en/develop/articles/intel-trust-domain-extensions.html
 	// Exclude from lint checking for it won't be used on arm64 code
 	tdxProtection
 
diff --git a/src/runtime/virtcontainers/qemu.go b/src/runtime/virtcontainers/qemu.go
index ba86c3d63a6c5158b3d0f7e6ae6af865dddb9d8d..2c6311c067935a2c5da0a1018420bab684b670e8 100644
--- a/src/runtime/virtcontainers/qemu.go
+++ b/src/runtime/virtcontainers/qemu.go
@@ -681,7 +681,7 @@ func (q *qemu) CreateVM(ctx context.Context, id string, network Network, hypervi
 		Debug:          hypervisorConfig.Debug,
 	}
 
-	qemuConfig.Devices, qemuConfig.Bios, err = q.arch.appendProtectionDevice(qemuConfig.Devices, firmwarePath, firmwareVolumePath)
+	qemuConfig.Devices, qemuConfig.Bios, err = q.arch.appendProtectionDevice(qemuConfig.Devices, firmwarePath, firmwareVolumePath, q.config.AgentPolicy)
 	if err != nil {
 		return err
 	}
diff --git a/src/runtime/virtcontainers/qemu_amd64.go b/src/runtime/virtcontainers/qemu_amd64.go
index 6ebee26ce34b5137f88a78219340b1f0867bc7a8..0a0451cba1565358225875cf6506381f5d221aec 100644
--- a/src/runtime/virtcontainers/qemu_amd64.go
+++ b/src/runtime/virtcontainers/qemu_amd64.go
@@ -9,6 +9,8 @@ package virtcontainers
 
 import (
 	"context"
+	"crypto/sha256"
+	"encoding/base64"
 	"fmt"
 	"time"
 
@@ -280,7 +282,7 @@ func (q *qemuAmd64) enableProtection() error {
 }
 
 // append protection device
-func (q *qemuAmd64) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string) ([]govmmQemu.Device, string, error) {
+func (q *qemuAmd64) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string, agentPolicy string) ([]govmmQemu.Device, string, error) {
 	if q.sgxEPCSize != 0 {
 		devices = append(devices,
 			govmmQemu.Object{
@@ -305,6 +307,7 @@ func (q *qemuAmd64) appendProtectionDevice(devices []govmmQemu.Device, firmware,
 				Debug:          false,
 				File:           firmware,
 				FirmwareVolume: firmwareVolume,
+				TEEConfigData:  tdxMRCONFIGID(agentPolicy),
 			}), "", nil
 	case sevProtection:
 		return append(devices,
@@ -326,6 +329,7 @@ func (q *qemuAmd64) appendProtectionDevice(devices []govmmQemu.Device, firmware,
 				CBitPos:         cpuid.AMDMemEncrypt.CBitPosition,
 				ReducedPhysBits: 1,
 				SnpCertsPath:    q.snpCertsPath,
+				TEEConfigData:   snpHostData(agentPolicy),
 			}), "", nil
 	case noneProtection:
 
@@ -335,3 +339,36 @@ func (q *qemuAmd64) appendProtectionDevice(devices []govmmQemu.Device, firmware,
 		return devices, "", fmt.Errorf("Unsupported guest protection technology: %v", q.protection)
 	}
 }
+
+// return the policy hash in the host-data format expected by QEMU for SEV-SNP.
+func snpHostData(policy string) string {
+	if len(policy) == 0 {
+		return ""
+	}
+
+	h := sha256.New()
+	h.Write([]byte(policy))
+	hash := h.Sum(nil)
+	hvLogger.WithField("hash", hash).Info("policy hash")
+
+	encoded_hash := make([]byte, base64.StdEncoding.EncodedLen(len(hash)))
+	base64.StdEncoding.Encode(encoded_hash, hash)
+	return string(encoded_hash)
+}
+
+// return the policy hash in the mrconfigid format expected by QEMU for TDX.
+func tdxMRCONFIGID(policy string) string {
+	if len(policy) == 0 {
+		return ""
+	}
+
+	h := sha256.New()
+	h.Write([]byte(policy))
+	hash := h.Sum(nil)
+	hvLogger.WithField("hash", hash).Info("policy hash")
+
+	// Pad the hash to 48-bytes.
+	mrConfigId := append(hash, (&[16]byte{})[:]...)
+
+	return base64.StdEncoding.EncodeToString(mrConfigId)
+}
diff --git a/src/runtime/virtcontainers/qemu_amd64_test.go b/src/runtime/virtcontainers/qemu_amd64_test.go
index 1425cb38cfd79ab06b04f1dafbab9b7440901688..f0a9c691a6ffc6356f8f9a335e72b81239a2ef2c 100644
--- a/src/runtime/virtcontainers/qemu_amd64_test.go
+++ b/src/runtime/virtcontainers/qemu_amd64_test.go
@@ -9,6 +9,10 @@ package virtcontainers
 
 import (
 	"context"
+	"crypto/sha256"
+	"crypto/sha512"
+	"encoding/base64"
+	"encoding/hex"
 	"fmt"
 	"os"
 	"testing"
@@ -247,6 +251,34 @@ func TestQemuAmd64Microvm(t *testing.T) {
 	assert.False(amd64.supportGuestMemoryHotplug())
 }
 
+// return the policy hash in the host-data format expected by QEMU for SEV-SNP.
+func testSnpHostData(policy string) string {
+	if len(policy) == 0 {
+		return ""
+	}
+
+	h := sha256.New()
+	h.Write([]byte(policy))
+	hash := h.Sum(nil)
+
+	encoded_hash := make([]byte, base64.StdEncoding.EncodedLen(len(hash)))
+	base64.StdEncoding.Encode(encoded_hash, hash)
+	return string(encoded_hash)
+}
+
+// return the policy hash in the mrconfigid format expected by QEMU for TDX.
+func testTdxMRCONFIGID(policy string) string {
+	if len(policy) == 0 {
+		return ""
+	}
+
+	h := sha512.New384()
+	h.Write([]byte(policy))
+	hash := h.Sum(nil)
+
+	return hex.EncodeToString(hash)
+}
+
 func TestQemuAmd64AppendProtectionDevice(t *testing.T) {
 	var devices []govmmQemu.Device
 	assert := assert.New(t)
@@ -255,30 +287,48 @@ func TestQemuAmd64AppendProtectionDevice(t *testing.T) {
 
 	id := amd64.(*qemuAmd64).devLoadersCount
 	firmware := "tdvf.fd"
+	policy := "package test1"
+	hostData := testSnpHostData(policy)
+	mrconfigid := testTdxMRCONFIGID(policy)
 	var bios string
 	var err error
-	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "")
-	assert.NoError(err)
 
 	// non-protection
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", "")
+	assert.NoError(err)
+	assert.NotEmpty(bios)
+
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", policy)
+	assert.NoError(err)
 	assert.NotEmpty(bios)
 
 	// pef protection
 	amd64.(*qemuAmd64).protection = pefProtection
-	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	amd64.(*qemuAmd64).protection = pefProtection
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", policy)
 	assert.Error(err)
 	assert.Empty(bios)
 
 	// Secure Execution protection
 	amd64.(*qemuAmd64).protection = seProtection
-	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", policy)
 	assert.Error(err)
 	assert.Empty(bios)
 
 	// sev protection
 	amd64.(*qemuAmd64).protection = sevProtection
 
-	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "")
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", "")
 	assert.NoError(err)
 	assert.Empty(bios)
 
@@ -295,10 +345,42 @@ func TestQemuAmd64AppendProtectionDevice(t *testing.T) {
 
 	assert.Equal(expectedOut, devices)
 
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", policy)
+	assert.NoError(err)
+	assert.Empty(bios)
+
+	expectedOut = append(expectedOut,
+		govmmQemu.Object{
+			Type:            govmmQemu.SEVGuest,
+			ID:              "sev",
+			Debug:           false,
+			File:            firmware,
+			CBitPos:         cpuid.AMDMemEncrypt.CBitPosition,
+			ReducedPhysBits: 1,
+		},
+	)
+
+	assert.Equal(expectedOut, devices)
+
 	// snp protection
 	amd64.(*qemuAmd64).protection = snpProtection
 
-	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "")
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", "")
+	assert.NoError(err)
+	assert.Empty(bios)
+
+	expectedOut = append(expectedOut,
+		govmmQemu.Object{
+			Type:            govmmQemu.SNPGuest,
+			ID:              "snp",
+			Debug:           false,
+			File:            firmware,
+			CBitPos:         cpuid.AMDMemEncrypt.CBitPosition,
+			ReducedPhysBits: 1,
+		},
+	)
+
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", policy)
 	assert.NoError(err)
 	assert.Empty(bios)
 
@@ -310,6 +392,7 @@ func TestQemuAmd64AppendProtectionDevice(t *testing.T) {
 			File:            firmware,
 			CBitPos:         cpuid.AMDMemEncrypt.CBitPosition,
 			ReducedPhysBits: 1,
+			TEEConfigData:   hostData,
 		},
 	)
 
@@ -318,7 +401,7 @@ func TestQemuAmd64AppendProtectionDevice(t *testing.T) {
 	// tdxProtection
 	amd64.(*qemuAmd64).protection = tdxProtection
 
-	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "")
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", "")
 	assert.NoError(err)
 	assert.Empty(bios)
 
@@ -334,4 +417,23 @@ func TestQemuAmd64AppendProtectionDevice(t *testing.T) {
 	)
 
 	assert.Equal(expectedOut, devices)
+
+	id += 1
+	devices, bios, err = amd64.appendProtectionDevice(devices, firmware, "", policy)
+	assert.NoError(err)
+	assert.Empty(bios)
+
+	expectedOut = append(expectedOut,
+		govmmQemu.Object{
+			Driver:        govmmQemu.Loader,
+			Type:          govmmQemu.TDXGuest,
+			ID:            "tdx",
+			DeviceID:      fmt.Sprintf("fd%d", id),
+			Debug:         false,
+			File:          firmware,
+			TEEConfigData: mrconfigid,
+		},
+	)
+
+	assert.Equal(expectedOut, devices)
 }
diff --git a/src/runtime/virtcontainers/qemu_arch_base.go b/src/runtime/virtcontainers/qemu_arch_base.go
index fd92be772446f30058d4424f7a330a0bc23ff433..662466f5846c22b4c7fa6b62b1a272258e2e4143 100644
--- a/src/runtime/virtcontainers/qemu_arch_base.go
+++ b/src/runtime/virtcontainers/qemu_arch_base.go
@@ -162,7 +162,7 @@ type qemuArch interface {
 	// This implementation is architecture specific, some archs may need
 	// a firmware, returns a string containing the path to the firmware that should
 	// be used with the -bios option, ommit -bios option if the path is empty.
-	appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string) ([]govmmQemu.Device, string, error)
+	appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string, agentPolicy string) ([]govmmQemu.Device, string, error)
 
 	// scans the PCIe space and returns the biggest BAR sizes for 32-bit
 	// and 64-bit addressable memory
@@ -897,7 +897,7 @@ func (q *qemuArchBase) setPFlash(p []string) {
 }
 
 // append protection device
-func (q *qemuArchBase) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string) ([]govmmQemu.Device, string, error) {
+func (q *qemuArchBase) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string, agentPolicy string) ([]govmmQemu.Device, string, error) {
 	hvLogger.WithField("arch", runtime.GOARCH).Warnf("Confidential Computing has not been implemented for this architecture")
 	return devices, firmware, nil
 }
diff --git a/src/runtime/virtcontainers/qemu_arm64.go b/src/runtime/virtcontainers/qemu_arm64.go
index a9b803f73275c1d5b9212a63fda097ebc33f1c9f..112fe358e4d76700ebe7a1d36e9ae42eb93611b7 100644
--- a/src/runtime/virtcontainers/qemu_arm64.go
+++ b/src/runtime/virtcontainers/qemu_arm64.go
@@ -154,7 +154,7 @@ func (q *qemuArm64) enableProtection() error {
 	return nil
 }
 
-func (q *qemuArm64) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string) ([]govmmQemu.Device, string, error) {
+func (q *qemuArm64) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string, agentPolicy string) ([]govmmQemu.Device, string, error) {
 	err := q.enableProtection()
 	if err != nil {
 		hvLogger.WithField("arch", runtime.GOARCH).Error(err)
diff --git a/src/runtime/virtcontainers/qemu_arm64_test.go b/src/runtime/virtcontainers/qemu_arm64_test.go
index 07e67ac8c1479c67f4b4ffa850dddb8d1e0680e4..8b6bd03eb9d10f0c37dbdbb3fb5fa48585659e96 100644
--- a/src/runtime/virtcontainers/qemu_arm64_test.go
+++ b/src/runtime/virtcontainers/qemu_arm64_test.go
@@ -182,42 +182,77 @@ func TestQemuArm64AppendProtectionDevice(t *testing.T) {
 	var err error
 
 	// no protection
-	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "")
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Empty(devices)
+	assert.Empty(bios)
+	assert.NoError(err)
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "XYZ")
 	assert.Empty(devices)
 	assert.Empty(bios)
 	assert.NoError(err)
 
 	// PEF protection
 	arm64.(*qemuArm64).protection = pefProtection
-	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Empty(devices)
+	assert.Empty(bios)
+	assert.NoError(err)
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "11111111111")
 	assert.Empty(devices)
 	assert.Empty(bios)
 	assert.NoError(err)
 
 	// Secure Execution protection
 	arm64.(*qemuArm64).protection = seProtection
-	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Empty(devices)
+	assert.Empty(bios)
+	assert.NoError(err)
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "ABCD")
 	assert.Empty(devices)
 	assert.Empty(bios)
 	assert.NoError(err)
 
 	// SEV protection
 	arm64.(*qemuArm64).protection = sevProtection
-	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Empty(devices)
+	assert.Empty(bios)
+	assert.NoError(err)
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "Fc+jr0/5HZMfG0uu54bbUsYuu8K0G7PXH8WNc4idAT8=")
 	assert.Empty(devices)
 	assert.Empty(bios)
 	assert.NoError(err)
 
 	// SNP protection
 	arm64.(*qemuArm64).protection = snpProtection
-	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Empty(devices)
+	assert.Empty(bios)
+	assert.NoError(err)
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "Fc+jr0/5HZMfG0uu54bbUsYuu8K0G7PXH8WNc4idAT8=")
 	assert.Empty(devices)
 	assert.Empty(bios)
 	assert.NoError(err)
 
 	// TDX protection
 	arm64.(*qemuArm64).protection = tdxProtection
-	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "")
+	assert.Empty(devices)
+	assert.Empty(bios)
+	assert.NoError(err)
+
+	devices, bios, err = arm64.appendProtectionDevice(devices, firmware, "", "123456789012345678901234567890123456789012345678")
 	assert.Empty(devices)
 	assert.Empty(bios)
 	assert.NoError(err)
diff --git a/src/runtime/virtcontainers/qemu_ppc64le.go b/src/runtime/virtcontainers/qemu_ppc64le.go
index d2e0228c8be8eae3ae24f3aa81b6423735f51320..ed7a14c4dc4262a0f1d77f6efa11310479fa1ecb 100644
--- a/src/runtime/virtcontainers/qemu_ppc64le.go
+++ b/src/runtime/virtcontainers/qemu_ppc64le.go
@@ -157,7 +157,7 @@ func (q *qemuPPC64le) enableProtection() error {
 }
 
 // append protection device
-func (q *qemuPPC64le) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string) ([]govmmQemu.Device, string, error) {
+func (q *qemuPPC64le) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string, agentPolicy string) ([]govmmQemu.Device, string, error) {
 	switch q.protection {
 	case pefProtection:
 		return append(devices,
diff --git a/src/runtime/virtcontainers/qemu_ppc64le_test.go b/src/runtime/virtcontainers/qemu_ppc64le_test.go
index 85e1dfe8050e3c64545e2031420058aad004f2ab..0c2f4b923d5550b67ad8c767124d8414b47d4c0b 100644
--- a/src/runtime/virtcontainers/qemu_ppc64le_test.go
+++ b/src/runtime/virtcontainers/qemu_ppc64le_test.go
@@ -60,39 +60,63 @@ func TestQemuPPC64leAppendProtectionDevice(t *testing.T) {
 	var devices []govmmQemu.Device
 	var bios, firmware string
 	var err error
-	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "")
-	assert.NoError(err)
 
 	//no protection
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "")
+	assert.NoError(err)
+	assert.Empty(bios)
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "FOObar")
+	assert.NoError(err)
 	assert.Empty(bios)
 
 	//Secure Execution protection
 	ppc64le.(*qemuPPC64le).protection = seProtection
-	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "adasawdq")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	//SEV protection
 	ppc64le.(*qemuPPC64le).protection = sevProtection
-	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "Fc+jr0/5HZMfG0uu54bbUsYuu8K0G7PXH8WNc4idAT8=")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	//SNP protection
 	ppc64le.(*qemuPPC64le).protection = snpProtection
-	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "Fc+jr0/5HZMfG0uu54bbUsYuu8K0G7PXH8WNc4idAT8=")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	//TDX protection
 	ppc64le.(*qemuPPC64le).protection = tdxProtection
-	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "123456789012345678901234567890123456789012345678")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	//PEF protection
 	ppc64le.(*qemuPPC64le).protection = pefProtection
-	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "")
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "")
 	assert.NoError(err)
 	assert.Empty(bios)
 
@@ -107,4 +131,19 @@ func TestQemuPPC64leAppendProtectionDevice(t *testing.T) {
 	}
 	assert.Equal(expectedOut, devices)
 
+	devices, bios, err = ppc64le.appendProtectionDevice(devices, firmware, "", "abc")
+	assert.NoError(err)
+	assert.Empty(bios)
+
+	expectedOut = append(expectedOut,
+		govmmQemu.Object{
+			Driver:   govmmQemu.SpaprTPMProxy,
+			Type:     govmmQemu.PEFGuest,
+			ID:       pefID,
+			DeviceID: tpmID,
+			File:     tpmHostPath,
+		},
+	)
+
+	assert.Equal(expectedOut, devices)
 }
diff --git a/src/runtime/virtcontainers/qemu_s390x.go b/src/runtime/virtcontainers/qemu_s390x.go
index 29eaafe5b3fe0ecf9f10bc49ede3465d2cf8ec3e..787a0e589a71dabb5acaedd66e36bb5f7d9662d0 100644
--- a/src/runtime/virtcontainers/qemu_s390x.go
+++ b/src/runtime/virtcontainers/qemu_s390x.go
@@ -337,7 +337,7 @@ func (q *qemuS390x) enableProtection() error {
 
 // appendProtectionDevice appends a QEMU object for Secure Execution.
 // Takes devices and returns updated version. Takes BIOS and returns it (no modification on s390x).
-func (q *qemuS390x) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string) ([]govmmQemu.Device, string, error) {
+func (q *qemuS390x) appendProtectionDevice(devices []govmmQemu.Device, firmware, firmwareVolume string, agentPolicy string) ([]govmmQemu.Device, string, error) {
 	switch q.protection {
 	case seProtection:
 		return append(devices,
diff --git a/src/runtime/virtcontainers/qemu_s390x_test.go b/src/runtime/virtcontainers/qemu_s390x_test.go
index 24a67bdd9e591ead96fbaea473cb662526dedbf3..3f5f84afffeec6fed0ba624408158425090fe88a 100644
--- a/src/runtime/virtcontainers/qemu_s390x_test.go
+++ b/src/runtime/virtcontainers/qemu_s390x_test.go
@@ -111,40 +111,64 @@ func TestQemuS390xAppendProtectionDevice(t *testing.T) {
 	var devices []govmmQemu.Device
 	var bios, firmware string
 	var err error
-	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "")
-	assert.NoError(err)
 
 	// no protection
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "")
+	assert.NoError(err)
+	assert.Empty(bios)
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "s390x_test")
+	assert.NoError(err)
 	assert.Empty(bios)
 
 	// PEF protection
 	s390x.(*qemuS390x).protection = pefProtection
-	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "1234")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	// TDX protection
 	s390x.(*qemuS390x).protection = tdxProtection
-	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "123456789012345678901234567890123456789012345678")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	// SEV protection
 	s390x.(*qemuS390x).protection = sevProtection
-	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "")
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "Fc+jr0/5HZMfG0uu54bbUsYuu8K0G7PXH8WNc4idAT8=")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	// SNP protection
 	s390x.(*qemuS390x).protection = snpProtection
-	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "")
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "")
+	assert.Error(err)
+	assert.Empty(bios)
+
+	s390x.(*qemuS390x).protection = snpProtection
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "Fc+jr0/5HZMfG0uu54bbUsYuu8K0G7PXH8WNc4idAT8=")
 	assert.Error(err)
 	assert.Empty(bios)
 
 	// Secure Execution protection
 	s390x.(*qemuS390x).protection = seProtection
 
-	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "")
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "")
 	assert.NoError(err)
 	assert.Empty(bios)
 
@@ -155,4 +179,17 @@ func TestQemuS390xAppendProtectionDevice(t *testing.T) {
 		},
 	}
 	assert.Equal(expectedOut, devices)
+
+	devices, bios, err = s390x.appendProtectionDevice(devices, firmware, "", "foo")
+	assert.NoError(err)
+	assert.Empty(bios)
+
+	expectedOut = append(expectedOut,
+		govmmQemu.Object{
+			Type: govmmQemu.SecExecGuest,
+			ID:   secExecID,
+		},
+	)
+
+	assert.Equal(expectedOut, devices)
 }
diff --git a/src/runtime/virtcontainers/sandbox.go b/src/runtime/virtcontainers/sandbox.go
index 3711da7f5eace937aa96c10208406b6f1752adcf..4192cb93845e789ed449e017843ad3cca92a3b31 100644
--- a/src/runtime/virtcontainers/sandbox.go
+++ b/src/runtime/virtcontainers/sandbox.go
@@ -613,6 +613,7 @@ func newSandbox(ctx context.Context, sandboxConfig SandboxConfig, factory Factor
 
 	sandboxConfig.HypervisorConfig.VMStorePath = s.store.RunVMStoragePath()
 	sandboxConfig.HypervisorConfig.RunStorePath = s.store.RunStoragePath()
+	sandboxConfig.HypervisorConfig.AgentPolicy = sandboxConfig.AgentConfig.Policy
 
 	spec := s.GetPatchedOCISpec()
 	if spec != nil && spec.Process.SelinuxLabel != "" {
