From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Markus Rudy <mr@edgeless.systems>
Date: Tue, 2 Sep 2025 10:33:45 +0200
Subject: [PATCH] genpolicy: allow image_guest_pull

This adds an additional version of allow_storage that checks Nydus
guest pull instructions. The agent takes the image reference from the
source field, so this is what we need to check. The driver_options field
is actually not used by the agent, so we remove it from the storage
definition to minimize the attack surface and the fields we need to
verify.

Since containerd removes the image tag if the reference has a digest, we
cannot compare the strings byte for byte. Instead, we only compare the
digest parts, which are considered sufficient to identify an image.
---
 src/agent/src/storage/image_pull_handler.rs | 65 ++-------------------
 src/runtime/virtcontainers/kata_agent.go    | 17 +-----
 src/tools/genpolicy/genpolicy-settings.json |  4 +-
 src/tools/genpolicy/rules.rego              | 47 +++++++++++----
 src/tools/genpolicy/src/policy.rs           | 14 +++++
 src/tools/genpolicy/src/registry.rs         | 26 ++++-----
 6 files changed, 68 insertions(+), 105 deletions(-)

diff --git a/src/agent/src/storage/image_pull_handler.rs b/src/agent/src/storage/image_pull_handler.rs
index 74686abf43436d9c5c5117d061f1faed79783f74..e927668e85b61c1d242c1052bf50d7a599e33600 100644
--- a/src/agent/src/storage/image_pull_handler.rs
+++ b/src/agent/src/storage/image_pull_handler.rs
@@ -5,12 +5,12 @@
 
 use super::new_device;
 use crate::confidential_data_hub;
-use crate::confidential_data_hub::image::{is_sandbox, unpack_pause_image};
+use crate::confidential_data_hub::image::unpack_pause_image;
 use crate::rpc::CONTAINER_BASE;
 use crate::storage::{StorageContext, StorageHandler};
 use anyhow::{anyhow, Result};
+use kata_types::mount::StorageDevice;
 use kata_types::mount::KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL;
-use kata_types::mount::{ImagePullVolume, StorageDevice};
 use protocols::agent::Storage;
 use safe_path::scoped_join;
 use std::sync::Arc;
@@ -19,20 +19,6 @@ use tracing::instrument;
 #[derive(Debug)]
 pub struct ImagePullHandler {}
 
-impl ImagePullHandler {
-    fn get_image_info(storage: &Storage) -> Result<ImagePullVolume> {
-        for option in storage.driver_options.iter() {
-            if let Some((key, value)) = option.split_once('=') {
-                if key == KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL {
-                    let imagepull_volume: ImagePullVolume = serde_json::from_str(value)?;
-                    return Ok(imagepull_volume);
-                }
-            }
-        }
-        Err(anyhow!("missing Image information for ImagePull volume"))
-    }
-}
-
 #[async_trait::async_trait]
 impl StorageHandler for ImagePullHandler {
     #[instrument]
@@ -46,9 +32,6 @@ impl StorageHandler for ImagePullHandler {
         storage: Storage,
         ctx: &mut StorageContext,
     ) -> Result<Arc<dyn StorageDevice>> {
-        //Currently the image metadata is not used to pulling image in the guest.
-        let image_pull_volume = Self::get_image_info(&storage)?;
-        debug!(ctx.logger, "image_pull_volume = {:?}", image_pull_volume);
         let image_name = storage.source();
         debug!(ctx.logger, "image_name = {:?}", image_name);
 
@@ -57,11 +40,8 @@ impl StorageHandler for ImagePullHandler {
             .clone()
             .ok_or_else(|| anyhow!("failed to get container id"))?;
 
-        info!(
-            ctx.logger,
-            "image metadata: {:?}", image_pull_volume.metadata
-        );
-        if is_sandbox(&image_pull_volume.metadata) {
+        if cid == ctx.sandbox.lock().await.id {
+            // This is the sandbox container, so we just mount the built-in pause image.
             let mount_path = unpack_pause_image(&cid)?;
             return new_device(mount_path);
         }
@@ -89,40 +69,3 @@ impl StorageHandler for ImagePullHandler {
         new_device(bundle_path)
     }
 }
-
-#[cfg(test)]
-mod tests {
-    use std::collections::HashMap;
-
-    use kata_types::mount::{ImagePullVolume, KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL};
-    use protocols::agent::Storage;
-
-    use crate::storage::image_pull_handler::ImagePullHandler;
-
-    #[test]
-    fn test_get_image_info() {
-        let mut res = HashMap::new();
-        res.insert("key1".to_string(), "value1".to_string());
-        res.insert("key2".to_string(), "value2".to_string());
-
-        let image_pull = ImagePullVolume {
-            metadata: res.clone(),
-        };
-
-        let image_pull_str = serde_json::to_string(&image_pull);
-        assert!(image_pull_str.is_ok());
-
-        let storage = Storage {
-            driver: KATA_VIRTUAL_VOLUME_IMAGE_GUEST_PULL.to_string(),
-            driver_options: vec![format!("image_guest_pull={}", image_pull_str.ok().unwrap())],
-            ..Default::default()
-        };
-
-        match ImagePullHandler::get_image_info(&storage) {
-            Ok(image_info) => {
-                assert_eq!(image_info.metadata, res);
-            }
-            Err(e) => panic!("err = {}", e),
-        }
-    }
-}
diff --git a/src/runtime/virtcontainers/kata_agent.go b/src/runtime/virtcontainers/kata_agent.go
index 7c22373e4d2472493e51b70fbae57d8299ea6b67..7cbe478bbc1d9188e403e7fe30151b26803053d2 100644
--- a/src/runtime/virtcontainers/kata_agent.go
+++ b/src/runtime/virtcontainers/kata_agent.go
@@ -1694,7 +1694,7 @@ func getContainerTypeforCRI(c *Container) (string, string) {
 	return "", ""
 }
 
-func handleImageGuestPullBlockVolume(c *Container, virtualVolumeInfo *types.KataVirtualVolume, vol *grpc.Storage) (*grpc.Storage, error) {
+func handleImageGuestPullBlockVolume(c *Container, vol *grpc.Storage) (*grpc.Storage, error) {
 	container_annotations := c.GetAnnotations()
 	containerType, criContainerType := getContainerTypeforCRI(c)
 
@@ -1727,20 +1727,9 @@ func handleImageGuestPullBlockVolume(c *Container, virtualVolumeInfo *types.Kata
 			return nil, fmt.Errorf("Failed to get image name from annotations")
 		}
 	}
-	virtualVolumeInfo.Source = image_ref
 
-	//merge virtualVolumeInfo.ImagePull.Metadata and container_annotations
-	for k, v := range container_annotations {
-		virtualVolumeInfo.ImagePull.Metadata[k] = v
-	}
-
-	no, err := json.Marshal(virtualVolumeInfo.ImagePull)
-	if err != nil {
-		return nil, err
-	}
 	vol.Driver = types.KataVirtualVolumeImageGuestPullType
-	vol.DriverOptions = append(vol.DriverOptions, types.KataVirtualVolumeImageGuestPullType+"="+string(no))
-	vol.Source = virtualVolumeInfo.Source
+	vol.Source = image_ref
 	vol.Fstype = typeOverlayFS
 	return vol, nil
 }
@@ -1751,7 +1740,7 @@ func handleVirtualVolumeStorageObject(c *Container, blockDeviceId string, virtVo
 	if virtVolume.VolumeType == types.KataVirtualVolumeImageGuestPullType {
 		var err error
 		vol = &grpc.Storage{}
-		vol, err = handleImageGuestPullBlockVolume(c, virtVolume, vol)
+		vol, err = handleImageGuestPullBlockVolume(c, vol)
 		if err != nil {
 			return nil, err
 		}
diff --git a/src/tools/genpolicy/genpolicy-settings.json b/src/tools/genpolicy/genpolicy-settings.json
index a0c0c5acf68bdd24e6a187101c9cff9a692dc9f2..34a743b102b8d0db8c576187a9f71aae53251486 100644
--- a/src/tools/genpolicy/genpolicy-settings.json
+++ b/src/tools/genpolicy/genpolicy-settings.json
@@ -319,12 +319,12 @@
         "image_layer_verification" : "none"
     },
     "kata_config": {
-        "confidential_guest": false,
+        "confidential_guest": true,
         "oci_version": "1.1.0"
     },
     "cluster_config": {
         "pause_container_image": "mcr.microsoft.com/oss/kubernetes/pause:3.6",
-        "guest_pull": false
+        "guest_pull": true
     },
     "request_defaults": {
         "CreateContainerRequest": {
diff --git a/src/tools/genpolicy/rules.rego b/src/tools/genpolicy/rules.rego
index 842fc326c023029b2e34c132401a51d04006c605..066c702530943f264a4d5a4cc5a4c0bc17567e43 100644
--- a/src/tools/genpolicy/rules.rego
+++ b/src/tools/genpolicy/rules.rego
@@ -1017,10 +1017,9 @@ mount_source_allows(p_mount, i_mount, bundle_id, sandbox_id) if {
 allow_storages(p_storages, i_storages, bundle_id, sandbox_id) if {
     p_count := count(p_storages)
     i_count := count(i_storages)
-    img_pull_count := count([s | s := i_storages[_]; s.driver == "image_guest_pull"])
-    print("allow_storages: p_count =", p_count, "i_count =", i_count, "img_pull_count =", img_pull_count)
+    print("allow_storages: p_count =", p_count, "i_count =", i_count)
 
-    p_count == i_count - img_pull_count
+    p_count == i_count
 
     image_info := allow_container_image_storage(p_storages)
     layer_ids := image_info.layer_ids
@@ -1066,15 +1065,6 @@ allow_storage(p_storages, i_storage, bundle_id, sandbox_id, layer_ids, root_hash
 
     print("allow_storage: true")
 }
-allow_storage(p_storages, i_storage, bundle_id, sandbox_id, layer_ids, root_hashes) if {
-    i_storage.driver == "image_guest_pull"
-    print("allow_storage with image_guest_pull: start")
-    i_storage.fstype == "overlay"
-    i_storage.fs_group == null
-    count(i_storage.options) == 0
-    # TODO: Check Mount Point, Source, Driver Options, etc.
-    print("allow_storage with image_guest_pull: true")
-}
 
 allow_storage_source(p_storage, i_storage, bundle_id) if {
     print("allow_storage_source 1: start")
@@ -1104,6 +1094,23 @@ allow_storage_source(p_storage, i_storage, bundle_id) if {
 
     print("allow_storage_source 3: true")
 }
+allow_storage_source(p_storage, i_storage, bundle_id) if {
+    print("allow_storage_source 4: start")
+    p_storage.driver == "image_guest_pull"
+    i_storage.driver == "image_guest_pull"
+    p_source := p_storage.source
+    i_source := i_storage.source
+
+    digest_re := "^[^@]+(@.+)?$"
+
+    print("allow_storage_source 4: p_source =", p_source, "i_source =", i_source)
+
+    p_match := regex.find_all_string_submatch_n(digest_re, p_source, 1)
+    i_match := regex.find_all_string_submatch_n(digest_re, i_source, 1)
+    p_match[0][1] == i_match[0][1]
+
+    print("allow_storage_source 4: true")
+}
 
 allow_storage_options(p_storage, i_storage, layer_ids, root_hashes) if {
     print("allow_storage_options 1: start")
@@ -1272,6 +1279,22 @@ allow_mount_point(p_storage, i_storage, bundle_id, sandbox_id, layer_ids) if {
 
     print("allow_mount_point 5: true")
 }
+allow_mount_point(p_storage, i_storage, bundle_id, sandbox_id, layer_ids) if {
+    p_storage.fstype == "overlay" 
+
+    mount1 := p_storage.mount_point
+    print("allow_mount_point 6: mount1 =", mount1)
+
+    mount2 := replace(mount1, "$(cpath)", policy_data.common.cpath)
+    print("allow_mount_point 6: mount2 =", mount2)
+
+    mount3 := replace(mount2, "$(bundle-id)", bundle_id)
+    print("allow_mount_point 6: mount3 =", mount3)
+
+    regex.match(mount3, i_storage.mount_point)
+
+    print("allow_mount_point 6: true")
+}
 
 # ExecProcessRequest.process.Capabilities
 allow_exec_caps(i_caps) if {
diff --git a/src/tools/genpolicy/src/policy.rs b/src/tools/genpolicy/src/policy.rs
index d28f23df2572ee4f0a44e5af283c45291ac4f2d5..27e549c23d52e99ed14c63fe7a1d0f94bc955cf9 100644
--- a/src/tools/genpolicy/src/policy.rs
+++ b/src/tools/genpolicy/src/policy.rs
@@ -629,6 +629,20 @@ impl AgentPolicy {
             &self.config.settings,
         );
 
+        
+    if self.config.settings.cluster_config.guest_pull {
+        let image_ref = if is_pause_container { "pause".to_string() } else { yaml_container.image.clone() }; 
+        storages.push(agent::Storage{
+            driver: "image_guest_pull".to_string(),
+            driver_options: Vec::new(),
+            source: image_ref,
+            fstype: "overlay".to_string(),
+            options: Vec::new(),
+            mount_point: "^$(cpath)/$(bundle-id)/rootfs$".to_string(),
+            ..Default::default()
+        });
+    }
+
         let mut linux = containerd::get_linux(is_privileged);
         linux.Namespaces = get_kata_namespaces(is_pause_container, use_host_network);
 
diff --git a/src/tools/genpolicy/src/registry.rs b/src/tools/genpolicy/src/registry.rs
index 14cc666822be6b7799df56dab72de97ed7366150..bbdfa33350865982b2a368bbe7e7202b1ad6adc3 100644
--- a/src/tools/genpolicy/src/registry.rs
+++ b/src/tools/genpolicy/src/registry.rs
@@ -174,24 +174,18 @@ impl Container {
                 // Find the last layer with an /etc/* file, respecting whiteouts.
                 let mut passwd = String::new();
                 let mut group = String::new();
-                // Nydus/guest_pull doesn't make available passwd/group files from layers properly.
-                // See issue https://github.com/kata-containers/kata-containers/issues/11162
-                if !config.settings.cluster_config.guest_pull {
-                    for layer in &image_layers {
-                        if layer.passwd == WHITEOUT_MARKER {
-                            passwd = String::new();
-                        } else if !layer.passwd.is_empty() {
-                            passwd = layer.passwd.clone();
-                        }
+                for layer in &image_layers {
+                    if layer.passwd == WHITEOUT_MARKER {
+                        passwd = String::new();
+                    } else if !layer.passwd.is_empty() {
+                        passwd = layer.passwd.clone();
+                    }
 
-                        if layer.group == WHITEOUT_MARKER {
-                            group = String::new();
-                        } else if !layer.group.is_empty() {
-                            group = layer.group.clone();
-                        }
+                    if layer.group == WHITEOUT_MARKER {
+                        group = String::new();
+                    } else if !layer.group.is_empty() {
+                        group = layer.group.clone();
                     }
-                } else {
-                    info!("Guest pull is enabled, skipping passwd/group file parsing");
                 }
 
                 Ok(Container {
