"use strict";(self.webpackChunkcontrast_docs=self.webpackChunkcontrast_docs||[]).push([[1749],{15467:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"architecture/attestation/atls","title":"Attested TLS","description":"Remote attestation verifies the integrity of code and configuration deployed to a confidential VM (CVM).","source":"@site/versioned_docs/version-1.12/architecture/attestation/atls.md","sourceDirName":"architecture/attestation","slug":"/architecture/attestation/atls","permalink":"/contrast/architecture/attestation/atls","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/contrast/edit/main/docs/versioned_docs/version-1.12/architecture/attestation/atls.md","tags":[],"version":"1.12","frontMatter":{},"sidebar":"docs","previous":{"title":"AMD SEV-SNP","permalink":"/contrast/architecture/attestation/amd-details"},"next":{"title":"Secrets & recovery","permalink":"/contrast/architecture/secrets"}}');var i=n(74848),r=n(28453);const o={},a="Attested TLS",c={},h=[{value:"Conceptual messages",id:"conceptual-messages",level:2},{value:"TLS extensions",id:"tls-extensions",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"attested-tls",children:"Attested TLS"})}),"\n",(0,i.jsxs)(t.p,{children:["Remote attestation verifies the integrity of code and configuration deployed to a confidential VM (CVM).\nThe concept is covered in depth on the ",(0,i.jsx)(t.a,{href:"/contrast/architecture/attestation/overview",children:"remote attestation"})," page.\nContrast uses remote attestation in two ways:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The Coordinator verifies workload initializers, according to the permitted workloads in the manifest."}),"\n",(0,i.jsx)(t.li,{children:"Workload owners and data owners verify the Coordinator, according to its reproducible reference values."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Most of the time, verifiers want to establish a secure channel to the attester in order to exchange further messages.\nFor example, the Coordinator hands out secrets to workloads or seed share owners over this secure channel.\nContrast uses a protocol on top of TLS 1.2, together referred to as ",(0,i.jsx)(t.em,{children:"aTLS"}),", to establish such a channel and verify the attestation at the same time."]}),"\n",(0,i.jsx)(t.h2,{id:"conceptual-messages",children:"Conceptual messages"}),"\n",(0,i.jsxs)(t.p,{children:["A TLS connection is established between a client and a server.\nContrast's aTLS, on the other hand, can attest unidirectional (client to server or server to client) and even bidirectional.\nTo avoid confusion, we're going to refer to the part requesting an attestation document as the ",(0,i.jsx)(t.em,{children:"initiator"})," and the part producing the document as the ",(0,i.jsx)(t.em,{children:"responder"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The protocol starts with the initiator creating a random value called a nonce.\nThis nonce is intended to demonstrate freshness of the attestation evidence.\nIf the responder embeds this nonce into the evidence, the initiator knows that the evidence was created specifically for this connection."}),"\n",(0,i.jsxs)(t.p,{children:["Next, the initiator sends an attestation request, including the nonce, to the responder.\nThe responder creates a fresh asymmetric private key, self-signs a certificate with this key, and uses both to establish a TLS connection to the initiator.\nIt also computes a cryptographic hash over the nonce and the public key, and requests an attestation report using the hash as ",(0,i.jsx)(t.code,{children:"REPORTDATA"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The responder now sends the attestation report back to the initiator, over the TLS channel just established.\nThe initiator observes the public key used by the responder, and calculates the expected hash from nonce and public key.\nFinally, the initiator verifies that the attestation evidence matches the reference values and that the ",(0,i.jsx)(t.code,{children:"REPORTDATA"})," is set to the expected hash."]}),"\n",(0,i.jsx)(t.p,{children:"At this point, the initiator knows that the responder runs the expected software, because it verified the evidence.\nIt can also be certain that the other end of the TLS channel terminates at the responder, because it knows that the expected software generated the key.\nThe initiator also knows that the key was generated for this TLS connection only because of the nonce embedded in the attestation report.\nThus, the attestation evidence is cryptographically tied to the established TLS channel, and the initiator successfully authenticated the responder."}),"\n",(0,i.jsx)(t.h2,{id:"tls-extensions",children:"TLS extensions"}),"\n",(0,i.jsx)(t.p,{children:"Contrast embeds the exchange of attestation requests and responses into the TLS handshake.\nSince there is no standard for such an embedding yet, Contrast repurposes existing TLS extension points.\nWhile these weren't originally designed for conveying attestation documents, this approach allows to use Go's TLS implementation without modification."}),"\n",(0,i.jsx)(t.p,{children:"To illustrate the full protocol, we're going to discuss mutual attestation, where both the TLS client and the TLS server act as initiator and responder.\nFor single-sided attestation, the respective requests and responses are simply not sent."}),"\n",(0,i.jsxs)(t.p,{children:["When a client initiates a TLS connection, it starts the TLS handshake by sending a ",(0,i.jsx)(t.code,{children:"ClientHello"})," message to the server.\nThe request for attestation is included as an ",(0,i.jsx)(t.a,{href:"https://www.rfc-editor.org/rfc/rfc7301",children:"Application-Layer Protocol Negotiation (ALPN)"})," next protocol choice.\nThe server parses the nonce from the protocol string and creates the TLS private key and the attestation report.\nIt embeds the report as an ",(0,i.jsx)(t.a,{href:"https://www.rfc-editor.org/rfc/rfc5280#section-4.2",children:"X.509 certificate extension"})," into the self-signed certificate and sends the ",(0,i.jsx)(t.code,{children:"ServerHello"})," and ",(0,i.jsx)(t.code,{children:"ServerCertificate"})," TLS messages."]}),"\n",(0,i.jsxs)(t.p,{children:["Now the server sends a ",(0,i.jsx)(t.a,{href:"https://www.rfc-editor.org/rfc/rfc5246#section-7.4.4",children:(0,i.jsx)(t.code,{children:"CertificateRequest"})})," message to the client, embedding the nonce into the ",(0,i.jsx)(t.em,{children:"Distinguished Name"})," field.\nThe client parses the nonce from this field and creates the TLS private key and the attestation report.\nLike the server, it embeds the report as a certificate extension and sends it back to the server with the ",(0,i.jsx)(t.code,{children:"ClientCertificate"})," message."]}),"\n",(0,i.jsx)(t.p,{children:"The following diagram shows the relevant messages carrying attestation protocol information.\nSome messages of the TLS 1.2 handshake that aren't relevant to attestation are omitted."}),"\n",(0,i.jsx)(t.mermaid,{value:"sequenceDiagram\n    Client->>Server: ClientHello { ALPN: [nonce-1] }\n    Server->>Client: ServerCertificate { Ext: [report(nonce-1, pubkey-server)] }\n    Server->>Client: CertificateRequest { DN: [nonce-2] }\n    Client->>Server: ClientCertificate { Ext: [report(nonce-2, pubkey-client)] }"})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(96540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);