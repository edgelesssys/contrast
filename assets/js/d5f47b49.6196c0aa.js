"use strict";(globalThis.webpackChunkcontrast_docs=globalThis.webpackChunkcontrast_docs||[]).push([[81314],{28453(e,t,n){n.d(t,{R:()=>o,x:()=>a});var s=n(96540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}},70721(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"architecture/features-limitations","title":"Planned features and limitations","description":"This section lists planned features and current limitations of Contrast.","source":"@site/versioned_docs/version-1.16/architecture/features-limitations.md","sourceDirName":"architecture","slug":"/architecture/features-limitations","permalink":"/contrast/architecture/features-limitations","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/contrast/edit/main/docs/versioned_docs/version-1.16/architecture/features-limitations.md","tags":[],"version":"1.16","frontMatter":{},"sidebar":"docs","previous":{"title":"K8s YAML elements","permalink":"/contrast/architecture/k8s-yaml-elements"},"next":{"title":"Telemetry & data collection","permalink":"/contrast/architecture/telemetry"}}');var i=n(74848),r=n(28453);const o={},a="Planned features and limitations",l={},c=[{value:"Availability",id:"availability",level:2},{value:"Kubernetes features",id:"kubernetes-features",level:2},{value:"Runtime policies",id:"runtime-policies",level:2},{value:"Tooling integration",id:"tooling-integration",level:2},{value:"GPU attestation",id:"gpu-attestation",level:2},{value:"Miscellaneous",id:"miscellaneous",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"planned-features-and-limitations",children:"Planned features and limitations"})}),"\n",(0,i.jsx)(t.p,{children:"This section lists planned features and current limitations of Contrast."}),"\n",(0,i.jsx)(t.h2,{id:"availability",children:"Availability"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Bare-metal support"}),": Support for running ",(0,i.jsx)(t.a,{href:"/contrast/howto/cluster-setup/bare-metal",children:"Contrast on bare-metal Kubernetes"})," is available for AMD SEV-SNP and Intel TDX."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Public cloud"})," is limited to cloud vendors providing the required hardware as bare-metal instances, ideally as part of their managed Kubernetes offerings."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"kubernetes-features",children:"Kubernetes features"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Persistent volumes"}),": Contrast only supports volumes with ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#volume-mode",children:(0,i.jsx)(t.code,{children:"volumeMode: Block"})}),". These block devices are provided by the untrusted environment and should be treated accordingly. The ",(0,i.jsx)(t.a,{href:"/contrast/architecture/secrets#secure-persistence",children:"transparent encryption feature"})," is recommended for secure persistence."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Volume sub-paths"}),": Mounting only a ",(0,i.jsx)(t.code,{children:"subPath"})," of a volume ",(0,i.jsx)(t.a,{href:"https://github.com/kata-containers/kata-containers/issues/10487",children:"isn't yet supported by Kata Containers"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Port forwarding"}),": This feature ",(0,i.jsx)(t.a,{href:"https://github.com/kata-containers/kata-containers/issues/1693",children:"isn't yet supported by Kata Containers"}),". You can ",(0,i.jsx)(t.a,{href:"/contrast/howto/workload-deployment/connect-to-coordinator#port-forwarding",children:"deploy a port-forwarder"})," as a workaround."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Resource limits"}),": Contrast doesn't support setting CPU limits on bare metal. Adding a resource request for CPUs will lead to attestation failures."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Termination messages"}),": ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/debug/debug-application/determine-reason-pod-failure/",children:"Custom termination messages"})," for confidential containers ",(0,i.jsx)(t.a,{href:"https://github.com/kata-containers/kata-containers/issues/10758",children:"aren't yet supported by Kata Containers"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"runtime-policies",children:"Runtime policies"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Order of events"}),": The current policy evaluation mechanism on API requests isn't stateful, so it can't ensure a prescribed order of events."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Absence of events"}),": Policies can't ensure certain events have happened. A container, such as the ",(0,i.jsx)(t.a,{href:"/contrast/architecture/components/service-mesh",children:"service mesh sidecar"}),", can be omitted entirely. Environment variables may be missing."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Volume integrity checks"}),": Integrity checks don't cover any volume mounts, such as ",(0,i.jsx)(t.code,{children:"ConfigMaps"})," and ",(0,i.jsx)(t.code,{children:"Secrets"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["The missing guarantee for startup order doesn't affect the security of Contrast's service mesh, see ",(0,i.jsx)(t.a,{href:"/contrast/architecture/components/service-mesh#service-mesh-startup-enforcement",children:"Service mesh startup enforcement"}),"."]})}),"\n",(0,i.jsx)(t.h2,{id:"tooling-integration",children:"Tooling integration"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"CLI availability"}),": The CLI tool is currently only available for Linux. This limitation arises because certain upstream dependencies haven't yet been ported to other platforms."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"gpu-attestation",children:"GPU attestation"}),"\n",(0,i.jsx)(t.p,{children:"While Contrast supports integration with confidential computing-enabled GPUs, such as NVIDIA's H100 series, attesting the integrity of the GPU device currently must be handled at the workload layer.\nThis means the workload needs to verify that the GPU is indeed an NVIDIA H100 running in confidential computing mode."}),"\n",(0,i.jsxs)(t.p,{children:["To simplify this process, the NVIDIA CC-Manager, which is\n",(0,i.jsx)(t.a,{href:"/contrast/howto/cluster-setup/bare-metal#preparing-a-cluster-for-gpu-usage",children:"deployed alongside the NVIDIA GPU operator"}),", enables the use of confidential computing GPUs (CC GPUs) within the workload. With the CC-Manager in place, the workload is responsible only for attesting the GPU's integrity."]}),"\n",(0,i.jsxs)(t.p,{children:["One way to perform this attestation is by using\n",(0,i.jsx)(t.a,{href:"https://github.com/NVIDIA/nvtrust",children:"nvTrust"}),", NVIDIA's reference implementation for GPU attestation.\nnvTrust provides tools and utilities to perform attestation within the workload."]}),"\n",(0,i.jsx)(t.h2,{id:"miscellaneous",children:"Miscellaneous"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Large pods on TDX"}),": On TDX platforms, Contrast currently only supports up to 64Gi of memory, including the fixed overhead of the Contrast runtime class."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);