"use strict";(self.webpackChunkcontrast_docs=self.webpackChunkcontrast_docs||[]).push([[3603],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(96540);const o={},i=r.createContext(o);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:t},e.children)}},65802:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"architecture/components/coordinator","title":"The Contrast Coordinator","description":"The Contrast Coordinator is the central remote attestation service of a Contrast deployment.","source":"@site/docs/architecture/components/coordinator.md","sourceDirName":"architecture/components","slug":"/architecture/components/coordinator","permalink":"/contrast/next/architecture/components/coordinator","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/contrast/edit/main/docs/docs/architecture/components/coordinator.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Initializer","permalink":"/contrast/next/architecture/components/initializer"},"next":{"title":"Service mesh","permalink":"/contrast/next/architecture/components/service-mesh"}}');var o=n(74848),i=n(28453);const s={},a="The Contrast Coordinator",d={},c=[{value:"The Manifest",id:"the-manifest",level:2},{value:"State",id:"state",level:2},{value:"Services",id:"services",level:2},{value:"Automatic recovery and high availability",id:"peer-recovery",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"the-contrast-coordinator",children:"The Contrast Coordinator"})}),"\n",(0,o.jsxs)(t.p,{children:["The Contrast Coordinator is the central remote attestation service of a Contrast deployment.\nIt runs inside a confidential container inside your cluster.\nThe Coordinator can be verified via remote attestation, and a Contrast deployment is self-contained.\nThe Coordinator is configured with a ",(0,o.jsx)(t.em,{children:"manifest"}),", a configuration file containing the reference attestation values of your deployment.\nIt ensures that your deployment's topology adheres to your specified manifest by verifying the identity and integrity of all confidential pods inside the deployment.\nThe Coordinator is also a certificate authority and issues certificates for your workload pods during the attestation procedure.\nYour workload pods can establish secure, encrypted communication channels between themselves based on these certificates using the Coordinator as the root CA.\nAs your app needs to scale, the Coordinator transparently verifies new instances and then provides them with their certificates to join the deployment."]}),"\n",(0,o.jsx)(t.p,{children:"To verify your deployment, the Coordinator's remote attestation statement combined with the manifest offers a concise single remote attestation statement for your entire deployment.\nA third party can use this to verify the integrity of your distributed app, making it easy to assure stakeholders of your app's identity and integrity."}),"\n",(0,o.jsx)(t.h2,{id:"the-manifest",children:"The Manifest"}),"\n",(0,o.jsx)(t.p,{children:"The manifest is the configuration file for the Coordinator, defining your confidential deployment.\nIt's automatically generated from your deployment by the Contrast CLI.\nIt currently consists of the following parts:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.em,{children:"Policies"}),": The identities of your Pods, represented by the hashes of their respective runtime policies."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.em,{children:"Reference Values"}),": The remote attestation reference values for the Kata confidential micro-VM that's the runtime environment of your Pods."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.em,{children:"WorkloadOwnerKeyDigest"}),": The workload owner's public key digest. Used for authenticating subsequent manifest updates."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.em,{children:"SeedshareOwnerKeys"}),": public keys of seed share owners. Used to authenticate user recovery and permission to handle the secret seed."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"state",children:"State"}),"\n",(0,o.jsx)(t.p,{children:"A Contrast Coordinator can be in one of three states:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["After a fresh installation, there is no manifest history and the Coordinator waits for its initialization by ",(0,o.jsx)(t.code,{children:"contrast set"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["When the Coordinator starts up and finds an existing manifest history, it enters ",(0,o.jsx)(t.em,{children:"recovery mode"}),".\nIt periodically tries to recover from its peers, or waits for the user to run ",(0,o.jsx)(t.code,{children:"contrast recover"})," if there are none.\nAll other API requests fail as long as the Coordinator is in recovery mode."]}),"\n",(0,o.jsxs)(t.li,{children:["If the Coordinator is synchronized to the latest manifest in history, it transitions to the ",(0,o.jsx)(t.code,{children:"Ready"})," state and starts accepting requests from workload initializers."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"services",children:"Services"}),"\n",(0,o.jsxs)(t.p,{children:["The Contrast Coordinator comes with two services: ",(0,o.jsx)(t.code,{children:"coordinator"})," and ",(0,o.jsx)(t.code,{children:"coordinator-ready"}),".\nThe ",(0,o.jsx)(t.code,{children:"coordinator"})," service is backed by all Coordinators, ready or not ready, and is intended to serve user API (that is, ",(0,o.jsx)(t.code,{children:"contrast"})," CLI commands).\nThe ",(0,o.jsx)(t.code,{children:"coordinator-ready"})," service only selects ready Coordinators which can serve the mesh API, and is intended to be used by initializers.\nThis endpoint is also suitable for verifying clients, since they will only get a successful response from a ready Coordinator."]}),"\n",(0,o.jsx)(t.h2,{id:"peer-recovery",children:"Automatic recovery and high availability"}),"\n",(0,o.jsx)(t.p,{children:"The Contrast Coordinator is deployed as a single replica in its default configuration.\nWhen this replica is restarted, for example for node maintenance, it needs to be recovered manually.\nThis can be avoided by running multiple replicas of the Coordinator, allowing the Coordinators to recover their peers automatically."}),"\n",(0,o.jsx)(t.p,{children:"Newly started (or restarted) Coordinator instances discover ready peers using the Kubernetes API server.\nIf a manifest history exists in the cluster and the Coordinator isn't updated yet to the latest manifest, it stays in a recovery loop.\nFor each ready Coordinator peer, it tries to reach that peer's mesh API endpoint directly (using the pod IP), attest to that Coordinator and receive the secret seed and the mesh CA credentials."}),"\n",(0,o.jsxs)(t.p,{children:["As long as a single Coordinator is initialized, the other instances will eventually recover from it.\n",(0,o.jsx)(t.code,{children:"StatefulSet"})," semantics guarantee that Coordinator pods are started predictably, and only after all existing Coordinators are ready.\nFor automatic peer recovery and high-availability, the Coordinator should be ",(0,o.jsx)(t.a,{href:"/contrast/next/howto/coordinator-ha",children:"scaled to at least 3 replicas"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);