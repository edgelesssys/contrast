"use strict";(self.webpackChunkcontrast_docs=self.webpackChunkcontrast_docs||[]).push([[744],{9171:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"howto/workload-deployment/recover-coordinator","title":"Recover Contrast Coordinator","description":"This step describes how the Contrast Coordinator can be recovered after a restart.","source":"@site/docs/howto/workload-deployment/recover-coordinator.md","sourceDirName":"howto/workload-deployment","slug":"/howto/workload-deployment/recover-coordinator","permalink":"/contrast/pr-preview/pr-1585/next/howto/workload-deployment/recover-coordinator","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/contrast/edit/main/docs/docs/howto/workload-deployment/recover-coordinator.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Communicate with workloads","permalink":"/contrast/pr-preview/pr-1585/next/howto/workload-deployment/workload-communication"},"next":{"title":"Set up encrypted volumes","permalink":"/contrast/pr-preview/pr-1585/next/howto/encrypted-storage"}}');var n=t(74848),a=t(28453);const s={},i="Recover Contrast Coordinator",c={},d=[{value:"Applicability",id:"applicability",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"How-to",id:"how-to",level:2},{value:"Connect to the Contrast Coordinator",id:"connect-to-the-contrast-coordinator",level:3},{value:"Recovery",id:"recovery",level:3}];function l(e){const o={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.header,{children:(0,n.jsx)(o.h1,{id:"recover-contrast-coordinator",children:"Recover Contrast Coordinator"})}),"\n",(0,n.jsx)(o.p,{children:"This step describes how the Contrast Coordinator can be recovered after a restart."}),"\n",(0,n.jsx)(o.h2,{id:"applicability",children:"Applicability"}),"\n",(0,n.jsx)(o.p,{children:"This step is necessary only when the Coordinator needs to be restarted."}),"\n",(0,n.jsx)(o.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsx)(o.li,{children:"A running Contrast deployment"}),"\n"]}),"\n",(0,n.jsx)(o.h2,{id:"how-to",children:"How-to"}),"\n",(0,n.jsx)(o.p,{children:"This page guides you through the process of connecting to the Coordinator and restoring its state."}),"\n",(0,n.jsx)(o.h3,{id:"connect-to-the-contrast-coordinator",children:"Connect to the Contrast Coordinator"}),"\n",(0,n.jsx)(o.p,{children:"The released Coordinator resource\nincludes a LoadBalancer definition we can use."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-sh",children:"coordinator=$(kubectl get svc coordinator -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\n"})}),"\n",(0,n.jsxs)(o.admonition,{title:"Port-forwarding of Confidential Containers",type:"info",children:[(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.code,{children:"kubectl port-forward"})," uses a Container Runtime Interface (CRI) method that isn't supported by the Kata shim.\nIf you can't use a public load balancer, you can deploy a port-forwarding pod to relay traffic to a Contrast pod:"]}),(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: port-forwarder-coordinator\nspec:\n  containers:\n    - name: port-forwarder\n      image: alpine/socat\n      args:\n        - -d\n        - TCP-LISTEN:1313,fork\n        - TCP:coordinator:1313\n      resources:\n        requests:\n          memory: 50Mi\n        limits:\n          memory: 50Mi\n"})}),(0,n.jsxs)(o.p,{children:["Upstream tracking issue: ",(0,n.jsx)(o.a,{href:"https://github.com/kata-containers/kata-containers/issues/1693",children:"https://github.com/kata-containers/kata-containers/issues/1693"}),"."]})]}),"\n",(0,n.jsx)(o.h3,{id:"recovery",children:"Recovery"}),"\n",(0,n.jsx)(o.p,{children:"If the Contrast Coordinator restarts, it enters recovery mode and waits for an operator to provide key material.\nFor demonstration purposes, you can simulate this scenario by deleting the Coordinator pod."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-sh",children:"kubectl delete pod -l app.kubernetes.io/name=coordinator\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Kubernetes schedules a new pod, but that pod doesn't have access to the key material the previous pod held in memory and can't issue certificates for workloads yet.\nYou can confirm this by running ",(0,n.jsx)(o.code,{children:"verify"})," again, or you can restart a workload pod, which should stay in the initialization phase.\nHowever, you can recover the Coordinator using the secret seed and the seed share owner key in your working directory."]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-sh",children:'contrast recover -c "${coordinator}:1313"\n'})}),"\n",(0,n.jsx)(o.p,{children:"Now that the Coordinator is recovered, all workloads should pass initialization and enter the running state.\nYou can now verify the Coordinator again, which should return the same manifest you set before."}),"\n",(0,n.jsx)(o.admonition,{type:"warning",children:(0,n.jsx)(o.p,{children:"The recovery process invalidates the mesh CA certificate:\nexisting workloads won't be able to communicate with workloads newly spawned.\nAll workloads should be restarted after the recovery succeeded."})})]})}function h(e={}){const{wrapper:o}={...(0,a.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,o,t)=>{t.d(o,{R:()=>s,x:()=>i});var r=t(96540);const n={},a=r.createContext(n);function s(e){const o=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(a.Provider,{value:o},e.children)}}}]);