"use strict";(self.webpackChunkcontrast_docs=self.webpackChunkcontrast_docs||[]).push([[9555],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(96540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}},34102:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/contrast_pki.drawio-a2442a1eeb081612c5ad587a58589ad4.svg"},48822:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"architecture/components/service-mesh","title":"Service mesh","description":"The Contrast service mesh secures the communication of the workload by automatically","source":"@site/docs/architecture/components/service-mesh.md","sourceDirName":"architecture/components","slug":"/architecture/components/service-mesh","permalink":"/contrast/pr-preview/pr-1436/next/architecture/components/service-mesh","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/contrast/edit/main/docs/docs/architecture/components/service-mesh.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Coordinator","permalink":"/contrast/pr-preview/pr-1436/next/architecture/components/coordinator"},"next":{"title":"Overview","permalink":"/contrast/pr-preview/pr-1436/next/architecture/attestation/overview"}}');var s=n(74848),r=n(28453);const a={},o="Service mesh",c={},h=[{value:"Service mesh startup enforcement",id:"service-mesh-startup-enforcement",level:2},{value:"Configuring the proxy",id:"configuring-the-proxy",level:2},{value:"Ingress",id:"ingress",level:3},{value:"Egress",id:"egress",level:3},{value:"Certificate authority",id:"certificate-authority",level:2},{value:"Public key infrastructure",id:"public-key-infrastructure",level:3},{value:"Certificate rotation",id:"certificate-rotation",level:3},{value:"Usage of the different certificates",id:"usage-of-the-different-certificates",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"service-mesh",children:"Service mesh"})}),"\n",(0,s.jsxs)(t.p,{children:["The Contrast service mesh secures the communication of the workload by automatically\nwrapping the network traffic inside mutual TLS (mTLS) connections. The\nverification of the endpoints in the connection establishment is based on\ncertificates that are part of the\n",(0,s.jsx)(t.a,{href:"#certificate-authority",children:"PKI of the Coordinator"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The service mesh can be enabled on a per-workload basis by adding a service mesh\nconfiguration to the workload's object annotations. During the ",(0,s.jsx)(t.code,{children:"contrast generate"}),"\nstep, the service mesh is added as a ",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/",children:"sidecar\ncontainer"})," to\nall workloads which have a specified configuration. The service mesh container first\nsets up ",(0,s.jsx)(t.code,{children:"iptables"})," rules based on its configuration and then starts\n",(0,s.jsx)(t.a,{href:"https://www.envoyproxy.io/",children:"Envoy"})," for TLS origination and termination."]}),"\n",(0,s.jsx)(t.h2,{id:"service-mesh-startup-enforcement",children:"Service mesh startup enforcement"}),"\n",(0,s.jsxs)(t.p,{children:["Since Contrast doesn't yet enforce the order in which the containers are started\n(see ",(0,s.jsx)(t.a,{href:"/contrast/pr-preview/pr-1436/next/architecture/features-limitations",children:"Limitations"}),"), we deny all incoming connections\nuntil the service mesh is fully configured.\nA systemd unit inside the podVM creates this deny rule.\nThe kata-agent systemd unit requires that this unit successfully runs and exits,\nbefore itself it can be started.\nTherefore, the deny rule is in place before any containers can be started."]}),"\n",(0,s.jsx)(t.p,{children:"If the user specifies no service mesh annotations, the Initializer takes care\nof removing the deny rule."}),"\n",(0,s.jsx)(t.h2,{id:"configuring-the-proxy",children:"Configuring the proxy"}),"\n",(0,s.jsx)(t.p,{children:"The service mesh container can be configured using the following object annotations:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"contrast.edgeless.systems/servicemesh-ingress"})," to configure ingress."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"contrast.edgeless.systems/servicemesh-egress"})," to configure egress."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"contrast.edgeless.systems/servicemesh-admin-interface-port"})," to configure the Envoy\nadmin interface. If not specified, no admin interface will be started."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["If you aren't using the automatic service mesh injection and want to configure the\nservice mesh manually, set the environment variables ",(0,s.jsx)(t.code,{children:"CONTRAST_INGRESS_PROXY_CONFIG"}),",\n",(0,s.jsx)(t.code,{children:"CONTRAST_EGRESS_PROXY_CONFIG"})," and ",(0,s.jsx)(t.code,{children:"CONTRAST_ADMIN_PORT"})," in the service mesh sidecar directly."]}),"\n",(0,s.jsx)(t.h3,{id:"ingress",children:"Ingress"}),"\n",(0,s.jsxs)(t.p,{children:["All TCP ingress traffic is routed over Envoy by default. Since we use\n",(0,s.jsx)(t.a,{href:"https://docs.kernel.org/networking/tproxy.html",children:"TPROXY"}),", the destination address\nremains the same throughout the packet handling."]}),"\n",(0,s.jsxs)(t.p,{children:["Any incoming connection is required to present a client certificate signed by the\n",(0,s.jsx)(t.a,{href:"#usage-of-the-different-certificates",children:"mesh CA certificate"}),".\nEnvoy presents a certificate chain of the mesh\ncertificate of the workload and the intermediate CA certificate as the server certificate."]}),"\n",(0,s.jsxs)(t.p,{children:["If the deployment contains workloads which should be reachable from outside the\nService Mesh, while still handing out the certificate chain, disable client\nauthentication by setting the annotation ",(0,s.jsx)(t.code,{children:"contrast.edgeless.systems/servicemesh-ingress"})," as\n",(0,s.jsx)(t.code,{children:"<name>#<port>#false"}),". Separate multiple entries with ",(0,s.jsx)(t.code,{children:"##"}),". You can choose any\ndescriptive string identifying the service on the given port for the ",(0,s.jsx)(t.code,{children:"<name>"})," field,\nas it's only informational."]}),"\n",(0,s.jsxs)(t.p,{children:["Disable redirection and TLS termination altogether by specifying\n",(0,s.jsx)(t.code,{children:"<name>#<port>#true"}),". This can be beneficial if the workload itself handles TLS\non that port or if the information exposed on this port is non-sensitive."]}),"\n",(0,s.jsx)(t.p,{children:"The following example workload exposes a web service on port 8080 and metrics on\nport 7890. The web server is exposed to a 3rd party end-user which wants to\nverify the deployment, therefore it's still required that the server hands out\nit certificate chain signed by the mesh CA certificate. The metrics should be\nexposed via TCP without TLS."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web\n  annotations:\n    contrast.edgeless.systems/servicemesh-ingress: "web#8080#false##metrics#7890#true"\nspec:\n  replicas: 1\n  template:\n    spec:\n      runtimeClassName: contrast-cc\n      containers:\n        - name: web-svc\n          image: ghcr.io/edgelesssys/frontend:v1.2.3@...\n          ports:\n            - containerPort: 8080\n              name: web\n            - containerPort: 7890\n              name: metrics\n'})}),"\n",(0,s.jsxs)(t.p,{children:["When invoking ",(0,s.jsx)(t.code,{children:"contrast generate"}),", the resulting deployment will be injected with the\nContrast service mesh as an init container."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'# ...\ninitContainers:\n  - env:\n      - name: CONTRAST_INGRESS_PROXY_CONFIG\n        value: "web#8080#false##metrics#7890#true"\n    image: "ghcr.io/edgelesssys/contrast/service-mesh-proxy:latest"\n    name: contrast-service-mesh\n    restartPolicy: Always\n    securityContext:\n      capabilities:\n        add:\n          - NET_ADMIN\n      privileged: true\n    volumeMounts:\n      - name: contrast-secrets\n        mountPath: /contrast\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Note, that changing the environment variables of the sidecar container directly will\nonly have an effect if the workload isn't configured to automatically generate a\nservice mesh component on ",(0,s.jsx)(t.code,{children:"contrast generate"}),". Otherwise, the service mesh sidecar\ncontainer will be regenerated on every invocation of the command."]}),"\n",(0,s.jsx)(t.h3,{id:"egress",children:"Egress"}),"\n",(0,s.jsx)(t.p,{children:"To be able to route the egress traffic of the workload through Envoy, the remote\nendpoints' IP address and port must be configurable."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Choose an IP address inside the ",(0,s.jsx)(t.code,{children:"127.0.0.0/8"})," CIDR and a port not yet in use\nby the pod."]}),"\n",(0,s.jsx)(t.li,{children:"Configure the workload to connect to this IP address and port."}),"\n",(0,s.jsxs)(t.li,{children:["Set ",(0,s.jsx)(t.code,{children:"<name>#<chosen IP>:<chosen port>#<original-hostname-or-ip>:<original-port>"}),"\nas the ",(0,s.jsx)(t.code,{children:"contrast.edgeless.systems/servicemesh-egress"})," workload annotation. Separate multiple\nentries with ",(0,s.jsx)(t.code,{children:"##"}),". Choose any string identifying the service on the given port as\n",(0,s.jsx)(t.code,{children:"<name>"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["This redirects the traffic over Envoy. The endpoint must present a valid\ncertificate chain which must be verifiable with the\n",(0,s.jsx)(t.a,{href:"#usage-of-the-different-certificates",children:"mesh CA certificate"}),".\nFurthermore, Envoy uses a certificate chain with the mesh certificate of the workload\nand the intermediate CA certificate as the client certificate."]}),"\n",(0,s.jsxs)(t.p,{children:["The following example workload has no ingress connections and two egress\nconnection to different microservices. The microservices are part\nof the confidential deployment. One is reachable under ",(0,s.jsx)(t.code,{children:"billing-svc:8080"})," and\nthe other under ",(0,s.jsx)(t.code,{children:"cart-svc:8080"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web\n  annotations:\n    contrast.edgeless.systems/servicemesh-egress: "billing#127.137.0.1:8081#billing-svc:8080##cart#127.137.0.2:8081#cart-svc:8080"\nspec:\n  replicas: 1\n  template:\n    spec:\n      runtimeClassName: contrast-cc\n      containers:\n        - name: currency-conversion\n          image: ghcr.io/edgelesssys/conversion:v1.2.3@...\n'})}),"\n",(0,s.jsx)(t.h2,{id:"certificate-authority",children:"Certificate authority"}),"\n",(0,s.jsx)(t.p,{children:"The Coordinator acts as a certificate authority (CA) for the workloads\ndefined in the manifest.\nAfter a workload pod's attestation has been verified by the Coordinator,\nit receives a mesh certificate and the mesh CA certificate.\nThe mesh certificate can be used for example in a TLS connection as the server or\nclient certificate to proof to the other party that the workload has been\nverified by the Coordinator. The other party can verify the mesh certificate\nwith the mesh CA certificate. While the certificates can be used by the workload\ndeveloper in different ways, they're automatically used in Contrast's service\nmesh to establish mTLS connections between workloads in the same deployment."}),"\n",(0,s.jsx)(t.h3,{id:"public-key-infrastructure",children:"Public key infrastructure"}),"\n",(0,s.jsx)(t.p,{children:"The Coordinator establishes a public key infrastructure (PKI) for all workloads\ncontained in the manifest. The Coordinator holds three certificates: the root CA\ncertificate, the intermediate CA certificate, and the mesh CA certificate.\nThe root CA certificate is a long-lasting certificate and its private key signs\nthe intermediate CA certificate. The intermediate CA certificate and the mesh CA\ncertificate share the same private key. This intermediate private key is used\nto sign the mesh certificates. Moreover, the intermediate private key and\ntherefore the intermediate CA certificate and the mesh CA certificate are\nrotated when setting a new manifest."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"PKI certificate chain",src:n(34102).A+""})}),"\n",(0,s.jsx)(t.h3,{id:"certificate-rotation",children:"Certificate rotation"}),"\n",(0,s.jsx)(t.p,{children:"Depending on the configuration of the first manifest, it allows the workload\nowner to update the manifest and, therefore, the deployment.\nWorkload owners and data owners can be mutually untrusted parties.\nTo protect against the workload owner silently introducing malicious containers,\nthe Coordinator rotates the intermediate private key every time the manifest is\nupdated and, therefore, the\nintermediate CA certificate and mesh CA certificate. If the user doesn't\ntrust the workload owner, they use the mesh CA certificate obtained when they\nverified the Coordinator and the manifest. This ensures that the user only\nconnects to workloads defined in the manifest they verified since only those\nworkloads' certificates are signed with this intermediate private key."}),"\n",(0,s.jsx)(t.p,{children:"Similarly, the service mesh also uses the mesh CA certificate obtained when the\nworkload was started, so the workload only trusts endpoints that have been\nverified by the Coordinator based on the same manifest. Consequently, a\nmanifest update requires a fresh rollout of the services in the service mesh."}),"\n",(0,s.jsx)(t.h3,{id:"usage-of-the-different-certificates",children:"Usage of the different certificates"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.strong,{children:"root CA certificate"})," is returned when verifying the Coordinator.\nThe data owner can use it to verify the mesh certificates of the workloads.\nThis should only be used if the data owner trusts all future updates to the\nmanifest and workloads. This is, for instance, the case when the workload owner is\nthe same entity as the data owner."]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.strong,{children:"mesh CA certificate"})," is returned when verifying the Coordinator.\nThe data owner can use it to verify the mesh certificates of the workloads.\nThis certificate is bound to the manifest set when the Coordinator is verified.\nIf the manifest is updated, the mesh CA certificate changes.\nNew workloads will receive mesh certificates signed by the ",(0,s.jsx)(t.em,{children:"new"})," mesh CA certificate.\nThe Coordinator with the new manifest needs to be verified to retrieve the new mesh CA certificate.\nThe service mesh also uses the mesh CA certificate to verify the mesh certificates."]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.strong,{children:"intermediate CA certificate"})," links the root CA certificate to the\nmesh certificate so that the mesh certificate can be verified with the root CA\ncertificate. It's part of the certificate chain handed out by\nendpoints in the service mesh."]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.strong,{children:"mesh certificate"})," is part of the certificate chain handed out by\nendpoints in the service mesh. During the startup of a pod, the Initializer\nrequests a certificate from the Coordinator. This mesh certificate will be returned if the Coordinator successfully\nverifies the workload. The mesh certificate\ncontains X.509 extensions with information from the workloads attestation\ndocument."]}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);