"use strict";(self.webpackChunkcontrast_docs=self.webpackChunkcontrast_docs||[]).push([[9682],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},58978:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"howto/vault","title":"Vault","description":"This how-to guides you through deploying Vault as a confidential deployment, using Contrast\'s built-in Vault support.","source":"@site/docs/howto/vault.md","sourceDirName":"howto","slug":"/howto/vault","permalink":"/contrast/pr-preview/pr-1832/next/howto/vault","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/contrast/edit/main/docs/docs/howto/vault.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Coordinator high-availability","permalink":"/contrast/pr-preview/pr-1832/next/howto/coordinator-ha"},"next":{"title":"Secure image store","permalink":"/contrast/pr-preview/pr-1832/next/howto/secure-image-store"}}');var a=n(74848),i=n(28453);const o={},r="Vault",l={},c=[{value:"Applicability",id:"applicability",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"How-to",id:"how-to",level:2},{value:"Background information",id:"background-information",level:3},{value:"Deploy Vault",id:"deploy-vault",level:3},{value:"Configure DNS",id:"configure-dns",level:3},{value:"Initialize Vault",id:"initialize-vault",level:3},{value:"Configure Vault",id:"configure-vault",level:3},{value:"Restart Vault with auto-unsealing",id:"restart-vault-with-auto-unsealing",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"vault",children:"Vault"})}),"\n",(0,a.jsx)(t.p,{children:"This how-to guides you through deploying Vault as a confidential deployment, using Contrast's built-in Vault support."}),"\n",(0,a.jsx)(t.h2,{id:"applicability",children:"Applicability"}),"\n",(0,a.jsx)(t.p,{children:"Confidential applications often need access to cryptographic keys and other secrets.\nContrast has built-in support for operating Hashicorp Vault / OpenBao, which can be used to setup a key management service for your applications.\nWhile this how-to uses an OpenBao server, the setup for Hashicorp Vault is very similar."}),"\n",(0,a.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/cluster-setup/bare-metal",children:"Set up cluster"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/install-cli",children:"Install CLI"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/workload-deployment/runtime-deployment",children:"Deploy the Contrast runtime"})}),"\n",(0,a.jsxs)(t.li,{children:["Install the ",(0,a.jsx)(t.code,{children:"bao"})," CLI (see ",(0,a.jsx)(t.a,{href:"https://openbao.org/docs/install/",children:"OpenBao installation instructions"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:["A domain name that resolves to the Vault service IP.\nFor testing purposes, you can use an entry in ",(0,a.jsx)(t.code,{children:"/etc/hosts"})," instead."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"how-to",children:"How-to"}),"\n",(0,a.jsxs)(t.p,{children:["The following sections explain how to add a Vault to your Contrast deployment, how to configure automatic unsealing and how to use Contrast certificates for authentication.\nRefer to the ",(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/architecture/secrets#transit-secrets-engine",children:"secrets page"})," for more information on Contrast's transit engine API."]}),"\n",(0,a.jsxs)(t.admonition,{title:"Example deployment",type:"note",children:[(0,a.jsx)(t.p,{children:"The vault configuration is of considerable size.\nTo help you get started, the Contrast release includes a demo resource definition for a Vault server.\nYou can download the demo app by running:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sh",children:"curl -fLO https://github.com/edgelesssys/contrast/releases/latest/download/vault-demo.yml --create-dirs --output-dir resources\n"})}),(0,a.jsx)(t.p,{children:"Consider this demo resource as a starting place and adapt it to fit your deployment."})]}),"\n",(0,a.jsx)(t.h3,{id:"background-information",children:"Background information"}),"\n",(0,a.jsxs)(t.p,{children:["The Vault deployment is defined as a ",(0,a.jsx)(t.code,{children:"StatefulSet"})," using an OpenBao image, with a mounted block device for persistent storage."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: vault\nspec:\n  template:\n    metadata:\n      annotations:\n        contrast.edgeless.systems/secure-pv: state:share\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The Contrast Initializer, running as an init container, uses the workload secret located at ",(0,a.jsx)(t.code,{children:"/contrast/secrets/workload-secret-seed"})," to generate an encryption key and initialize the block device ",(0,a.jsx)(t.code,{children:"state"})," as a LUKS-encrypted partition.\nBefore the Vault container starts, the Initializer opens the LUKS device using the generated key.\nThis unlocked device is then mounted by the Vault container and used as the backend storage volume ",(0,a.jsx)(t.code,{children:"share"}),".\nFor the Vault application, this process is entirely transparent, and the device behaves like a standard volume mount."]}),"\n",(0,a.jsx)(t.p,{children:"The LUKS encryption of the block device is primarily a convenience feature, enabling persistent storage at the filesystem level on confidential virtual machines.\nThe primary and security-relevant encryption mechanism remains Vault\u2019s own sealing process, which provides cryptographic protection of secrets even if the underlying storage is compromised."}),"\n",(0,a.jsxs)(t.p,{children:["Because the ",(0,a.jsx)(t.code,{children:"workload-secret-seed"})," is derived from the associated ",(0,a.jsx)(t.code,{children:"workloadSecretID"}),", any change to the ",(0,a.jsx)(t.code,{children:"workloadSecretID"})," after the block device has been initialized will result in a different key, making the mounted block device undecryptable.\nTherefore, it's critical to ensure that the ",(0,a.jsx)(t.code,{children:"workloadSecretID"})," is correctly aligned with the intended endpoint specified in Vault\u2019s unsealing configuration before the first ",(0,a.jsx)(t.code,{children:"contrast set"})," is executed.\nIn this example, the ",(0,a.jsx)(t.code,{children:"workloadSecretID"})," is set to ",(0,a.jsx)(t.code,{children:"vault_unsealing"})," with an annotation:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"spec:\n  template:\n    metadata:\n      annotations:\n        contrast.edgeless.systems/secure-pv: state:share\n        contrast.edgeless.systems/workload-secret-id: vault_unsealing\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Vault's TCP listener is configured to use the certificate provisioned by the initializer.\nBelow is the relevant excerpt from the example configuration file, denoted there as ",(0,a.jsx)(t.code,{children:"VAULT_CONFIG"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-hcl",children:'listener "tcp" {\n  address            = "0.0.0.0:8200"\n  tls_cert_file      = "/contrast/tls-config/certChain.pem"\n  tls_key_file       = "/contrast/tls-config/key.pem"\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The Vault configuration file would ideally just be mounted from the ",(0,a.jsx)(t.code,{children:"ConfigMap"})," into the server pod.\nHowever, this would be insecure, as the Vault configuration is sensitive but mounts aren't integrity-checked (see ",(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/hardening#limitations-inherent-to-policy-checking",children:"Hardening"}),").\nTherefore, the demo pod adds the configuration as an environment variable and extracts it to a memory-backed file before starting the server."]}),"\n",(0,a.jsx)(t.h3,{id:"deploy-vault",children:"Deploy Vault"}),"\n",(0,a.jsx)(t.p,{children:"Follow the steps of the generic workload deployment instructions:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/workload-deployment/add-coordinator",children:"Add the Coordinator."})}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/workload-deployment/generate-annotations",children:"Generate the policies."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["After running ",(0,a.jsx)(t.code,{children:"contrast generate"}),", add the desired Vault domain name to the vault ",(0,a.jsx)(t.code,{children:"SANs"})," array in ",(0,a.jsx)(t.code,{children:"manifest.json"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/workload-deployment/deploy-application",children:"Apply the resources."})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/contrast/pr-preview/pr-1832/next/howto/workload-deployment/set-manifest",children:"Set the manifest."})}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"configure-dns",children:"Configure DNS"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"bao"})," CLI, as well as the ",(0,a.jsx)(t.code,{children:"vault"})," CLI, need to be configured with an HTTPS endpoint, and that endpoint needs to match the certificate that Vault is presenting.\nBy default, the manifest only contains the Subject Alternative Name (SAN) ",(0,a.jsx)(t.code,{children:"vault"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"First, you need to know the public IP of the Vault service, which you can print with the following command:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sh",children:"kubectl get service vault -o=jsonpath='{.status.loadBalancer.ingress[0].ip}'\n"})}),"\n",(0,a.jsx)(t.p,{children:"If you added SANs in the previous step, these will also be included in the certificate.\nIn that case, you can configure your DNS service to resolve the additional SAN to the load balancer IP."}),"\n",(0,a.jsxs)(t.p,{children:["Alternatively, configure the system from which you access Vault to resolve ",(0,a.jsx)(t.code,{children:"vault"})," to the load balancer IP.\nOn Linux, you can modify ",(0,a.jsx)(t.code,{children:"/etc/hosts"})," for this."]}),"\n",(0,a.jsx)(t.h3,{id:"initialize-vault",children:"Initialize Vault"}),"\n",(0,a.jsxs)(t.p,{children:["A Vault instance needs to be initialized once before it can be used.\nInitialization is a sensitive operation that transfers key material, and should thus be executed on a secure system, by a trusted operator and over a secure channel.\nFor this demo, the machine hosting your Contrast workspace is sufficient.\nInitialize the Vault with the ",(0,a.jsx)(t.code,{children:"bao"})," CLI from within your workspace, using the Coordinator CA as a root of trust:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sh",children:"export VAULT_ADDR=https://${YOUR_VAULT_DOMAIN}:8200\nexport VAULT_CACERT=./coordinator-root-ca.pem\nbao operator init -format json | tee vault_secrets.json\nexport VAULT_TOKEN=$(jq -r '.root_token' < vault_secrets.json)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Upon successful initialization, this prints a root token and some recovery key shares and also writes them to the file ",(0,a.jsx)(t.code,{children:"vault_secrets.json"}),".\nThese are highly sensitive secrets and need to be guarded carefully!\nThe last command makes the Vault root token available to the ",(0,a.jsx)(t.code,{children:"bao"})," CLI, allowing you to configure Vault in the next section."]}),"\n",(0,a.jsx)(t.h3,{id:"configure-vault",children:"Configure Vault"}),"\n",(0,a.jsxs)(t.p,{children:["Vault can be configured to use Contrast certificates for authorization.\nThe following commands enable ",(0,a.jsx)(t.a,{href:"https://developer.hashicorp.com/vault/docs/auth/cert",children:"certificate authentication"})," and assign a policy ",(0,a.jsx)(t.code,{children:"contrast"})," to workloads with Contrast certificates."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sh",children:"bao auth enable cert\nbao write auth/cert/certs/coordinator display_name=coordinator policies=contrast certificate=@./mesh-ca.pem\n"})}),"\n",(0,a.jsxs)(t.p,{children:["For this demo, we're going to activate the KV secrets engine, write a demo secret and add the ",(0,a.jsx)(t.code,{children:"contrast"})," policy that allows Contrast workloads to access it."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sh",children:'bao secrets enable -version=1 kv\nbao kv put kv/my-secret my-value=s3cr3t\nbao policy write contrast - <<EOF\npath "kv/*"\n{\n  capabilities = ["create", "read", "update", "delete", "list"]\n}\nEOF\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The demo includes a simple deployment - ",(0,a.jsx)(t.code,{children:"vault-client"})," - that attempts to authenticate to Vault with its Contrast certificate and then tries to read a secret.\nAfter running the above commands, the pod should become ready and show the secret content in its log output."]}),"\n",(0,a.jsx)(t.h3,{id:"restart-vault-with-auto-unsealing",children:"Restart Vault with auto-unsealing"}),"\n",(0,a.jsx)(t.p,{children:"When a Vault pod is restarted, it must unseal its encrypted state. The sealing key isn't present in the restarted pod, but can be retrieved from the Coordinator's transit engine API after the Coordinator has attested the restarted pod."}),"\n",(0,a.jsxs)(t.p,{children:['To configure Vault to use the Coordinator\'s transit engine API for automatic unsealing, the following configuration is used in the demo deployment, which is part of the "vault-config" config map.\nNote that the ',(0,a.jsx)(t.code,{children:"key_name"})," needs to be equal to the ",(0,a.jsx)(t.code,{children:"workloadSecretID"})," of Vault."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-hcl",children:'seal "transit" {\n  address         = "https://coordinator:8200"\n  disable_renewal = "true"\n  key_name        = "vault_unsealing"\n  mount_path      = "transit/"\n  tls_ca_cert     = "/contrast/tls-config/mesh-ca.pem"\n  tls_client_cert = "/contrast/tls-config/certChain.pem"\n  tls_client_key  = "/contrast/tls-config/key.pem"\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"This configuration instructs Vault to unseal itself with key material obtained from the Coordinator.\nTo see this process in action, you can trigger a restart of your Vault pod:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sh",children:"kubectl rollout restart statefulset/vault\n"})}),"\n",(0,a.jsx)(t.p,{children:"When a new Vault pod starts, it runs the Contrast Initializer as part of its startup sequence.\nThe Initializer receives the same workload secret as before, allowing it to derive the correct encryption key and unlock the existing LUKS-encrypted block device.\nThis process ensures that the Vault backend can reattach the previously encrypted volume and access all stored data transparently.\nHowever, while this step enables access to the filesystem-level storage, it doesn't unlock access to the actual secrets.\nWhen the main Vault container starts, it finds the sealed data on the volume and begins the unsealing process."}),"\n",(0,a.jsx)(t.p,{children:"You can verify that the auto-unsealing process completed successful by inspecting the logs of the Vault pod, or by running"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sh",children:"bao status\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);